# ===============================================================
#          MESSAGES API ROUTES & SOCKET HANDLERS
# ===========================================================

online_users = {}

@app.route('/api/online-users')
@login_required
def get_online_users():
    """Get currently online users"""
    cleanup_disconnected_users()
    
    users = []
    for user_id, user_data in online_users.items():
        if user_data and 'user_id' in user_data:
            users.append({
                'user_id': user_data['user_id'],
                'username': user_data['username'],
                'is_admin': user_data.get('is_admin', False),
                'last_seen': user_data.get('last_seen'),
                'room': user_data.get('current_room', 'general')
            })
    
    return jsonify(users)

@app.route('/api/messages')
@login_required
def get_messages():
    """Get messages for a room with optional filtering"""
    room = request.args.get('room', 'general')
    since_id = request.args.get('since_id', 0, type=int)
    limit = request.args.get('limit', 100, type=int)
    
    try:
        query = Message.query.filter_by(room=room, is_deleted=False)
        
        if since_id > 0:
            query = query.filter(Message.id > since_id)
        
        messages = query.order_by(Message.created_at.asc()).limit(limit).all()
        
        read_message_ids = set()
        if current_user.is_authenticated:
            read_records = MessageRead.query.filter_by(user_id=current_user.id).all()
            read_message_ids = {record.message_id for record in read_records}
        
        # Format response
        messages_data = []
        for message in messages:
            message_data = {
                'id': message.id,
                'content': message.content,
                'user_id': message.user_id,
                'username': message.user.username,
                'is_admin': message.user.is_admin,
                'is_admin_message': message.is_admin_message,
                'created_at': message.created_at.isoformat(),
                'room': message.room,
                'is_read': message.id in read_message_ids,
                'parent_id': message.parent_id,
                'has_replies': len(message.replies) > 0 if message.replies else False
            }
            
            if message.parent_id:
                parent_message = Message.query.get(message.parent_id)
                if parent_message and not parent_message.is_deleted:
                    message_data['parent'] = {
                        'id': parent_message.id,
                        'content': parent_message.content,
                        'username': parent_message.user.username,
                        'user_id': parent_message.user_id
                    }
            
            messages_data.append(message_data)
        
        return jsonify({
            'success': True,
            'messages': messages_data,
            'room': room,
            'total': len(messages_data)
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/messages/read', methods=['POST'])
@login_required
def mark_messages_read():
    """Mark messages as read for current user"""
    try:
        data = request.get_json()
        message_ids = data.get('message_ids', [])
        
        if not message_ids:
            return jsonify({'success': False, 'error': 'No message IDs provided'}), 400
        
        for message_id in message_ids:
            existing_read = MessageRead.query.filter_by(
                message_id=message_id, 
                user_id=current_user.id
            ).first()
            
            if not existing_read:
                message_read = MessageRead(
                    message_id=message_id,
                    user_id=current_user.id
                )
                db.session.add(message_read)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Marked {len(message_ids)} messages as read',
            'read_count': len(message_ids)
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/messages/send', methods=['POST'])
@login_required
def send_message():
    """Send a message via HTTP API (fallback)"""
    try:
        data = request.get_json()
        content = data.get('content', '').strip()
        room = data.get('room', 'general')
        parent_id = data.get('parent_id')  # To track replies
        
        if not content:
            return jsonify({'success': False, 'error': 'Message content is required'}), 400
        
        if parent_id:
            parent_message = Message.query.get(parent_id)
            if not parent_message or parent_message.is_deleted:
                return jsonify({'success': False, 'error': 'Parent message not found'}), 404
        
        message = Message(
            content=content,
            user_id=current_user.id,
            room=room,
            is_admin_message=current_user.is_admin,
            parent_id=parent_id
        )
        
        db.session.add(message)
        db.session.commit()
        
        message_data = {
            'id': message.id,
            'content': message.content,
            'user_id': message.user_id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'is_admin_message': current_user.is_admin,
            'created_at': message.created_at.isoformat(),
            'room': room,
            'parent_id': parent_id,
            'is_read': False
        }
        
        if parent_id:
            parent_message = Message.query.get(parent_id)
            if parent_message and not parent_message.is_deleted:
                message_data['parent'] = {
                    'id': parent_message.id,
                    'content': parent_message.content,
                    'username': parent_message.user.username
                }
        
        socketio.emit('new_message', message_data, room=room)
        
        return jsonify({
            'success': True,
            'message': message_data
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/messages/<int:message_id>/reply', methods=['POST'])
@login_required
def reply_to_message(message_id):
    """Reply to a specific message"""
    try:
        data = request.get_json()
        content = data.get('content', '').strip()
        
        if not content:
            return jsonify({'success': False, 'error': 'Reply content is required'}), 400
        
        parent_message = Message.query.get(message_id)
        if not parent_message or parent_message.is_deleted:
            return jsonify({'success': False, 'error': 'Message not found'}), 404
        
        reply = Message(
            content=content,
            user_id=current_user.id,
            room=parent_message.room,
            is_admin_message=current_user.is_admin,
            parent_id=message_id
        )
        
        db.session.add(reply)
        db.session.commit()
        
        reply_data = {
            'id': reply.id,
            'content': reply.content,
            'user_id': reply.user_id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'is_admin_message': current_user.is_admin,
            'created_at': reply.created_at.isoformat(),
            'room': parent_message.room,
            'parent_id': message_id,
            'is_read': False,
            'parent': {
                'id': parent_message.id,
                'content': parent_message.content,
                'username': parent_message.user.username
            }
        }
        
        socketio.emit('new_message', reply_data, room=parent_message.room)
        
        return jsonify({
            'success': True,
            'message': reply_data
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/messages/<int:message_id>', methods=['DELETE'])
@login_required
def delete_message(message_id):
    """Delete a message (soft delete)"""
    try:
        message = Message.query.get(message_id)
        
        if not message:
            return jsonify({'success': False, 'error': 'Message not found'}), 404
        
        if message.user_id != current_user.id and not current_user.is_admin:
            return jsonify({'success': False, 'error': 'Permission denied'}), 403
        
        # Soft delete
        message.is_deleted = True
        message.deleted_at = nairobi_time()
        message.content = "[This message was deleted]"
        
        db.session.commit()
        
        socketio.emit('message_deleted', {
            'message_id': message_id,
            'room': message.room,
            'deleted_by': current_user.id,
            'is_admin_action': current_user.is_admin
        }, room=message.room)
        
        return jsonify({
            'success': True,
            'message': 'Message deleted successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/messages/<int:message_id>/replies')
@login_required
def get_message_replies(message_id):
    """Get replies for a specific message"""
    try:
        message = Message.query.get(message_id)
        
        if not message or message.is_deleted:
            return jsonify({'success': False, 'error': 'Message not found'}), 404
        
        replies = Message.query.filter_by(
            parent_id=message_id, 
            is_deleted=False
        ).order_by(Message.created_at.asc()).all()
        
        read_message_ids = set()
        if current_user.is_authenticated:
            read_records = MessageRead.query.filter_by(user_id=current_user.id).all()
            read_message_ids = {record.message_id for record in read_records}
        
        replies_data = []
        for reply in replies:
            reply_data = {
                'id': reply.id,
                'content': reply.content,
                'user_id': reply.user_id,
                'username': reply.user.username,
                'is_admin': reply.user.is_admin,
                'is_admin_message': reply.is_admin_message,
                'created_at': reply.created_at.isoformat(),
                'room': reply.room,
                'parent_id': reply.parent_id,
                'is_read': reply.id in read_message_ids
            }
            replies_data.append(reply_data)
        
        return jsonify({
            'success': True,
            'replies': replies_data,
            'parent_message': {
                'id': message.id,
                'content': message.content,
                'username': message.user.username
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# =========================================
#          EXTRA FUNCTIONS CLEAN UP - MEMORY CONSTRAIN
# ===========================================================

def cleanup_disconnected_users():
    """Remove users who haven't been seen for more than 30 seconds"""
    current_time = datetime.utcnow()
    disconnected_users = []
    
    for user_id, user_data in online_users.items():
        if user_data and 'last_seen' in user_data:
            last_seen = user_data['last_seen']
            if isinstance(last_seen, str):
                try:
                    last_seen = datetime.fromisoformat(last_seen.replace('Z', '+00:00'))
                except:
                    continue
            
            if current_time - last_seen > timedelta(seconds=30):
                disconnected_users.append(user_id)
    
    for user_id in disconnected_users:
        user_data = online_users.pop(user_id, None)
        if user_data:
            room = user_data.get('current_room', 'general')
            emit('user_left', {
                'user_id': user_data['user_id'],
                'username': user_data['username'],
                'message': f'{user_data["username"]} left the chat'
            }, room=room, include_self=False)

def update_user_presence(user_id, username, is_admin=False, room='general'):
    """Update user's online status and room"""
    online_users[user_id] = {
        'user_id': user_id,
        'username': username,
        'is_admin': is_admin,
        'current_room': room,
        'last_seen': datetime.utcnow().isoformat()
    }
    
    room_users = []
    for uid, user_data in online_users.items():
        if user_data and user_data.get('current_room') == room:
            room_users.append({
                'user_id': user_data['user_id'],
                'username': user_data['username'],
                'is_admin': user_data.get('is_admin', False)
            })
    
    emit('online_users_update', {'users': room_users}, room=room)

def broadcast_online_users():
    """Broadcast updated online users list to all rooms"""
    cleanup_disconnected_users()
    
    room_users = {}
    for user_id, user_data in online_users.items():
        if user_data and 'user_id' in user_data:
            room = user_data.get('current_room', 'general')
            if room not in room_users:
                room_users[room] = []
            
            room_users[room].append({
                'user_id': user_data['user_id'],
                'username': user_data['username'],
                'is_admin': user_data.get('is_admin', False)
            })
    
    for room, users in room_users.items():
        emit('online_users_update', {'users': users}, room=room)

# =========================================
#             SOCKET.IO HANDLERS
# =========================================

@socketio.on('connect')
def handle_connect():
    """Handle user connection"""
    if current_user.is_authenticated:
        update_user_presence(
            user_id=current_user.id,
            username=current_user.username,
            is_admin=current_user.is_admin,
            room='general'
        )
        
        join_room('general')
        
        emit('user_joined', {
            'user_id': current_user.id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'message': f'{current_user.username} joined the chat'
        }, room='general', include_self=False)
        
        emit('user_info', {
            'user_id': current_user.id,
            'username': current_user.username,
            'is_admin': current_user.is_admin
        })
        
        print(f"User {current_user.username} connected. Online users: {len(online_users)}")

@socketio.on('disconnect')
def handle_disconnect():
    """Handle user disconnection"""
    if current_user.is_authenticated:
        user_data = online_users.get(current_user.id)
        
        if user_data:
            room = user_data.get('current_room', 'general')
            
            online_users.pop(current_user.id, None)
            
            emit('user_left', {
                'user_id': current_user.id,
                'username': current_user.username,
                'message': f'{current_user.username} left the chat'
            }, room=room, include_self=False)
            
            broadcast_online_users()
        
        print(f"User {current_user.username} disconnected. Online users: {len(online_users)}")

# I'm not that good at this part
@socketio.on('join_room')
def handle_join_room(data):
    """Handle joining a room"""
    if current_user.is_authenticated:
        room = data.get('room', 'general')
        previous_room = online_users.get(current_user.id, {}).get('current_room', 'general')
        
        if previous_room != room:
            leave_room(previous_room)
            emit('user_left', {
                'user_id': current_user.id,
                'username': current_user.username,
                'message': f'{current_user.username} left {previous_room}'
            }, room=previous_room, include_self=False)
        
        join_room(room)
        
        update_user_presence(
            user_id=current_user.id,
            username=current_user.username,
            is_admin=current_user.is_admin,
            room=room
        )
        
        emit('user_joined', {
            'user_id': current_user.id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'message': f'{current_user.username} joined {room}'
        }, room=room, include_self=False)
        
        messages = Message.query.filter_by(room=room, is_deleted=False).order_by(Message.created_at.asc()).limit(50).all()
        
        read_message_ids = set()
        if current_user.is_authenticated:
            read_records = MessageRead.query.filter_by(user_id=current_user.id).all()
            read_message_ids = {record.message_id for record in read_records}
        
        for message in messages:
            message_data = {
                'id': message.id,
                'content': message.content,
                'user_id': message.user_id,
                'username': message.user.username,
                'is_admin': message.user.is_admin,
                'is_admin_message': message.is_admin_message,
                'created_at': message.created_at.isoformat(),
                'room': room,
                'is_read': message.id in read_message_ids,
                'parent_id': message.parent_id
            }
            
            if message.parent_id:
                parent_message = Message.query.get(message.parent_id)
                if parent_message and not parent_message.is_deleted:
                    message_data['parent'] = {
                        'id': parent_message.id,
                        'content': parent_message.content,
                        'username': parent_message.user.username
                    }
            
            emit('new_message', message_data)

@socketio.on('leave_room')
def handle_leave_room(data):
    """Handle leaving a room"""
    if current_user.is_authenticated:
        room = data.get('room', 'general')
        leave_room(room)
    
        update_user_presence(
            user_id=current_user.id,
            username=current_user.username,
            is_admin=current_user.is_admin,
            room='general'
        )
        
        emit('user_left', {
            'user_id': current_user.id,
            'username': current_user.username,
            'message': f'{current_user.username} left {room}'
        }, room=room, include_self=False)
        
        join_room('general')
        
        emit('room_left', {
            'room': room,
            'user_id': current_user.id,
            'username': current_user.username
        })

@socketio.on('send_message')
def handle_send_message(data):
    if not current_user.is_authenticated:
        return {'success': False, 'error': 'Not authenticated'}
    
    content = data.get('content', '').strip()
    room = data.get('room', 'general')
    parent_id = data.get('parent_id')
    
    if not content:
        return {'success': False, 'error': 'Empty message'}
    
    if parent_id:
        parent_message = Message.query.get(parent_id)
        if not parent_message or parent_message.is_deleted:
            return {'success': False, 'error': 'Parent message not found'}
    
    update_user_presence(
        user_id=current_user.id,
        username=current_user.username,
        is_admin=current_user.is_admin,
        room=room
    )
    
    message = Message(
        content=content,
        user_id=current_user.id,
        room=room,
        is_admin_message=current_user.is_admin,
        parent_id=parent_id
    )
    
    try:
        db.session.add(message)
        db.session.commit()
        
        message_data = {
            'id': message.id,
            'content': message.content,
            'user_id': message.user_id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'is_admin_message': current_user.is_admin,
            'created_at': message.created_at.isoformat(),
            'room': room,
            'parent_id': parent_id,
            'is_read': False
        }
        
        if parent_id:
            parent_message = Message.query.get(parent_id)
            if parent_message and not parent_message.is_deleted:
                message_data['parent'] = {
                    'id': parent_message.id,
                    'content': parent_message.content,
                    'username': parent_message.user.username
                }
        
        emit('new_message', message_data, room=room)
        
        return {'success': True, 'message': message_data}
        
    except Exception as e:
        db.session.rollback()
        return {'success': False, 'error': str(e)}

@socketio.on('delete_message')
def handle_delete_message(data):
    """Handle message deletion via WebSocket"""
    if not current_user.is_authenticated:
        return {'success': False, 'error': 'Not authenticated'}
    
    message_id = data.get('message_id')
    
    if not message_id:
        return {'success': False, 'error': 'Message ID required'}
    
    try:
        message = Message.query.get(message_id)
        
        if not message:
            return {'success': False, 'error': 'Message not found'}
        
        if message.user_id != current_user.id and not current_user.is_admin:
            return {'success': False, 'error': 'Permission denied'}
        
        # Soft delete message
        message.is_deleted = True
        message.deleted_at = nairobi_time()
        message.content = "[This message was deleted]"
        
        db.session.commit()
        
        emit('message_deleted', {
            'message_id': message_id,
            'room': message.room,
            'deleted_by': current_user.id,
            'is_admin_action': current_user.is_admin
        }, room=message.room)
        
        return {'success': True, 'message': 'Message deleted successfully'}
        
    except Exception as e:
        db.session.rollback()
        return {'success': False, 'error': str(e)}

@socketio.on('typing')
def handle_typing(data):
    """Handle typing indicator"""
    if current_user.is_authenticated:
        room = data.get('room', 'general')
        emit('user_typing', {
            'user_id': current_user.id,
            'username': current_user.username,
            'room': room
        }, room=room, include_self=False)

@socketio.on('ping')
def handle_ping(data):
    """Handle ping for connection health check"""
    if current_user.is_authenticated:
        user_room = online_users.get(current_user.id, {}).get('current_room', 'general')
        
        # Update user presence
        update_user_presence(
            user_id=current_user.id,
            username=current_user.username,
            is_admin=current_user.is_admin,
            room=user_room
        )
        
        emit('pong', {'timestamp': data.get('timestamp')})

@socketio.on('get_messages')
def handle_get_messages(data):
    if current_user.is_authenticated:
        room = data.get('room', 'general')
        since_id = data.get('since_id', 0)
        limit = data.get('limit', 100)
        
        try:
            query = Message.query.filter_by(room=room, is_deleted=False)
            if since_id > 0:
                query = query.filter(Message.id > since_id)
            
            messages = query.order_by(Message.created_at.asc()).limit(limit).all()
            
            read_message_ids = set()
            if current_user.is_authenticated:
                read_records = MessageRead.query.filter_by(user_id=current_user.id).all()
                read_message_ids = {record.message_id for record in read_records}
            
            messages_data = []
            for message in messages:
                message_data = {
                    'id': message.id,
                    'content': message.content,
                    'user_id': message.user_id,
                    'username': message.user.username,
                    'is_admin': message.user.is_admin,
                    'is_admin_message': message.is_admin_message,
                    'created_at': message.created_at.isoformat(),
                    'room': room,
                    'is_read': message.id in read_message_ids,
                    'parent_id': message.parent_id
                }
                
                if message.parent_id:
                    parent_message = Message.query.get(message.parent_id)
                    if parent_message and not parent_message.is_deleted:
                        message_data['parent'] = {
                            'id': parent_message.id,
                            'content': parent_message.content,
                            'username': parent_message.user.username
                        }
                
                messages_data.append(message_data)
            
            emit('messages_batch', {
                'room': room,
                'messages': messages_data,
                'since_id': since_id,
                'total': len(messages_data)
            })
            
        except Exception as e:
            emit('messages_error', {
                'error': str(e),
                'room': room
            })

@socketio.on('mark_read')
def handle_mark_read(data):
    if not current_user.is_authenticated:
        return
    
    message_ids = data.get('message_ids', [])
    
    if not message_ids:
        return
    
    try:
        for message_id in message_ids:
            existing_read = MessageRead.query.filter_by(
                message_id=message_id, 
                user_id=current_user.id
            ).first()
            
            if not existing_read:
                message_read = MessageRead(
                    message_id=message_id,
                    user_id=current_user.id
                )
                db.session.add(message_read)
        
        db.session.commit()
        
        emit('messages_read', {
            'message_ids': message_ids,
            'user_id': current_user.id,
            'username': current_user.username
        }, broadcast=True)
        
    except Exception as e:
        db.session.rollback()
        print(f"Error marking messages as read: {e}")