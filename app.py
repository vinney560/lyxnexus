#===========================================
import eventlet
eventlet.monkey_patch()
#===========================================

from flask_socketio import SocketIO, emit, join_room, leave_room

import os
from flask import Flask, jsonify, request, abort, send_from_directory, render_template, redirect, url_for, flash, session
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from flask import jsonify, request, send_file
from io import BytesIO
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import create_engine
from sqlalchemy.exc import OperationalError, ArgumentError
from sqlalchemy.orm import sessionmaker
from flask_cors import CORS
from datetime import timedelta, datetime, date
from flask_compress import Compress
from dotenv import load_dotenv
import traceback
import logging
import re
from flask_jwt_extended import JWTManager
from functools import wraps
from bs4 import BeautifulSoup
from flask_session import Session
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

#==========================================

app = Flask(__name__)
load_dotenv()

app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')

def database_url():
    db_1 = os.getenv('DATABASE_URL')
    db_2 = os.getenv('DATABASE_URL_2')
    db_3 = os.getenv('DATABASE_FALLBACK_URL')

    print(f"DB_1: {db_1}")
    print(f"DB_2: {db_2}")
    print(f"DB_3: {db_3}")

    for name, db_url in [("Aiven DB", db_1), ("Render DB", db_2)]:
        if db_url:
            try:
                engine = create_engine(db_url)
                engine.connect().close()
                print("=" * 70)
                print(f"✅ Connected to {name}")
                return db_url
            except OperationalError as e:
                print(f"❌ Failed to connect to {name}: {e}")
            except ArgumentError as e:
                print(f"⚠️ Invalid {name} URL: {e}")

    # Fallback to SQLite to prevent Runtime errors
    if db_3:
        if db_3.startswith("sqlite:///"):
            print("=" * 70)
            print("✅ Using local SQLite fallback database.")
            return db_3
        else:
            print("⚠️ Fallback DB URL invalid (should start with sqlite:///).")

    print("❌ All database connections failed!")
    return None

app.config['SQLALCHEMY_DATABASE_URI'] = database_url()
# Read from Aiven connection max pooling for reuse pool
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
    'pool_recycle': 40,  
    'pool_pre_ping': True,
    'pool_size': 6,
    'max_overflow': 5,
}
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

app.config["JWT_SECRET_KEY"] = os.getenv("JWT_SECRET_KEY", "4321REWQ")
CORS(app, resources={
    r'/*': {
        'origins': [
            r'https://*.onrender.com',
            r'http://viewtv.viewtv.gt.tc',
            f'http://localhost:47947'
        ]
    }
})

app.logger.setLevel(logging.INFO)

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)
app.permanent_session_lifetime = timedelta(hours=732)
app.config["SESSION_TYPE"] = "filesystem"
UPLOAD_FOLDER = os.path.join(app.root_path, 'uploads')
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# =======================================
#   SESSION INITIALIZATION
# =======================================
app.config['SESSION_TYPE'] = 'filesystem'                # store session data in server-side files
app.config['SESSION_PERMANENT'] = False                  # session ends when browser closes
app.config['SESSION_USE_SIGNER'] = True                  # adds an extra layer of security
app.config['SESSION_FILE_DIR'] = './flask_session/'      # directory for session files
app.config['SESSION_COOKIE_HTTPONLY'] = True             # prevents JavaScript access
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'            # prevents CSRF
app.config['SESSION_COOKIE_SECURE'] = True
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=31)
# =======================================
# ===============================
#   RATE LIMITER INITIALIZATION
# ===============================
limiter = Limiter(
    key_func=get_remote_address,  # identifies users by IP address
    app=app,                      # attach limiter to the Flask app
    default_limits=["200 per day", "50 per hour"]  # global limits
)
# ===============================
login_manager = LoginManager()
login_manager.init_app(app)
jwt = JWTManager(app)
login_manager.login_view = 'login'
Compress(app)
socketio = SocketIO(app, cors_allowed_origins="*", async_mode="eventlet", ping_timeout=20, ping_interval=10)
db = SQLAlchemy(app)
Session(app)

def nairobi_time():
    return (datetime.utcnow() + timedelta(hours=3)).strftime('%Y-%m-%d %H:%M:%S')

# =========================================
# USER MODEL
# =========================================
class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(200), default='User V', nullable=True)
    mobile = db.Column(db.String(20), unique=True, nullable=True)
    created_at = db.Column(db.DateTime, default=nairobi_time)
    is_admin = db.Column(db.Boolean, default=False)

    # Relationships
    announcements = db.relationship('Announcement', backref='author', lazy=True)
    assignments = db.relationship('Assignment', backref='creator', lazy=True)

    def validate_mobile(self, mobile):
        """Validate mobile number format"""
        if not mobile:
            return True
        mobile_regex = r'^(07|01)[0-9]{8}$'
        return re.match(mobile_regex, mobile) is not None

    def set_mobile(self, mobile):
        """Set mobile with validation"""
        if mobile and not self.validate_mobile(mobile):
            raise ValueError("Mobile number must be 10 digits starting with 07 or 01")
        self.mobile = mobile

# ========================================
# ANNOUNCEMENT MODEL
# ========================================
class Announcement(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=True)
    content = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, default=nairobi_time)
    
    #Relationships
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)

    file_name = db.Column(db.String(255), nullable=True)       # Original filename
    file_type = db.Column(db.String(100), nullable=True)       # MIME type
    file_data = db.Column(db.LargeBinary, nullable=True)       # Actual file content (bytes)

    def has_file(self):
        """Check if announcement has an attached file"""
        return bool(self.file_data and self.file_name)

    def get_file_url(self):
        if not self.has_file():
            return None
        return f"/announcement-file/{self.id}/{self.file_name}"

# =========================================
# TOPIC / THEME MODEL
# =========================================
class Topic(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), unique=True, nullable=True)
    description = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, default=nairobi_time)

    # Relationship
    assignments = db.relationship('Assignment', backref='topic', lazy=True)

# =========================================
# ASSIGNMENT MODEL
# =========================================
class Assignment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=True)
    description = db.Column(db.Text, nullable=True)
    due_date = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=nairobi_time)

    # Store the actual uploaded file
    file_data = db.Column(db.LargeBinary, nullable=True)   # actual file content (bytes)
    file_name = db.Column(db.String(1255), nullable=True)   # original filename
    file_type = db.Column(db.String(100), nullable=True)   # MIME type

    # Foreign keys
    topic_id = db.Column(db.Integer, db.ForeignKey('topic.id'), nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
# =========================================
# TIMETABLE MODEL
# =========================================
class Timetable(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    day_of_week = db.Column(db.String(20), nullable=False)
    start_time = db.Column(db.Time, nullable=False)
    end_time = db.Column(db.Time, nullable=False)
    subject = db.Column(db.String(200), nullable=False)
    room = db.Column(db.String(100), nullable=True)
    teacher = db.Column(db.String(200), nullable=True)
    created_at = db.Column(db.DateTime, default=nairobi_time)
    updated_at = db.Column(db.DateTime, default=nairobi_time, onupdate=nairobi_time)

    topic_id = db.Column(db.Integer, db.ForeignKey('topic.id'), nullable=True)
    
    # Relationship
    topic = db.relationship('Topic', backref='timetable_slots', lazy=True)

# =========================================
# MESSAGE MODELS
# ========================================
class Message(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    user_id = db.Column(
        db.Integer,
        db.ForeignKey('user.id', ondelete='CASCADE'),
        nullable=False
    )
    room = db.Column(db.String(100), default='general')
    is_admin_message = db.Column(db.Boolean, default=False)
    parent_id = db.Column(
        db.Integer,
        db.ForeignKey('message.id', ondelete='CASCADE'),
        nullable=True
    )
    is_deleted = db.Column(db.Boolean, default=False)
    deleted_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=nairobi_time)

    # Relationships
    user = db.relationship(
        'User',
        backref=db.backref('messages', lazy=True, cascade='all, delete-orphan')
    )

    parent = db.relationship(
        'Message',
        remote_side=[id],
        backref=db.backref('replies', lazy=True, cascade='all, delete-orphan')
    )

class MessageRead(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    message_id = db.Column(
        db.Integer,
        db.ForeignKey('message.id', ondelete='CASCADE'),
        nullable=False
    )
    user_id = db.Column(
        db.Integer,
        db.ForeignKey('user.id', ondelete='CASCADE'),
        nullable=False
    )
    read_at = db.Column(db.DateTime, default=nairobi_time)

    # Relationships
    message = db.relationship(
        'Message',
        backref=db.backref('read_records', lazy=True, cascade='all, delete-orphan')
    )
    user = db.relationship(
        'User',
        backref=db.backref('read_messages', lazy=True, cascade='all, delete-orphan')
    )    

#==========================================
# FILES MODEL
#==========================================
class File(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255), nullable=False)
    filename = db.Column(db.String(255), nullable=False)
    file_type = db.Column(db.String(100), nullable=False)
    file_size = db.Column(db.Integer, nullable=False)
    file_data = db.Column(db.LargeBinary, nullable=False)
    description = db.Column(db.Text)
    category = db.Column(db.String(100), default='general')
    uploaded_at = db.Column(db.DateTime, default=nairobi_time)
    updated_at = db.Column(db.DateTime, default=nairobi_time, onupdate=nairobi_time)
    
    # Foreign Keys
    uploaded_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
    # Relationships
    uploader = db.relationship('User', backref=db.backref('uploaded_files', lazy=True))
    
    def __repr__(self):
        return f'<File {self.name}>'

class TopicMaterial(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    topic_id = db.Column(db.Integer, db.ForeignKey('topic.id'), nullable=False)
    file_id = db.Column(db.Integer, db.ForeignKey('file.id'), nullable=False)
    display_name = db.Column(db.String(255), nullable=True)
    description = db.Column(db.Text, nullable=True)
    order_index = db.Column(db.Integer, default=0)
    created_at = db.Column(db.DateTime, default=nairobi_time)
    
    # Relationships
    topic = db.relationship('Topic', backref=db.backref('topic_materials', lazy=True))
    file = db.relationship('File', backref=db.backref('material_references', lazy=True))
    
    def __repr__(self):
        return f'<TopicMaterial {self.display_name or self.file.name}>'

# Ai DB for conversation tracking
class AIConversation(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    user_message = db.Column(db.Text, nullable=False)
    ai_response = db.Column(db.Text, nullable=False)
    context_used = db.Column(db.String(50), default='general')
    created_at = db.Column(db.DateTime, default=nairobi_time)
    
    # Relationships
    user = db.relationship('User', backref=db.backref('ai_conversations', lazy=True))

# Enhanced AI Conversation tracking with better organization
class AIConverse(db.Model):
    __tablename__ = 'ai_converse'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    user_message = db.Column(db.Text, nullable=False)
    ai_response = db.Column(db.Text, nullable=False)
    context_used = db.Column(db.String(50), default='general')
    message_type = db.Column(db.String(20), default='text')  # text, query, command, etc.
    tokens_used = db.Column(db.Integer, default=0)
    response_time = db.Column(db.Float, default=0.0)  # Response time in seconds
    api_model = db.Column(db.String(50), default='gemini-2.0-flash')
    was_successful = db.Column(db.Boolean, default=True)
    error_message = db.Column(db.Text, nullable=True)
    user_rating = db.Column(db.Integer, nullable=True, default=1)  # 1-5 rating
    created_at = db.Column(db.DateTime, default=nairobi_time)
    
    # Index for better performance
    __table_args__ = (
        db.Index('idx_user_created', 'user_id', 'created_at'),
        db.Index('idx_created_at', 'created_at'),
    )
    
    # Relationships
    user = db.relationship('User', backref=db.backref('ai_converse', lazy='dynamic', cascade='all, delete-orphan'))
    
    def to_dict(self):
        """Convert conversation to dictionary for JSON serialization"""
        return {
            'id': self.id,
            'user_id': self.user_id,
            'user_message': self.user_message,
            'ai_response': self.ai_response,
            'context_used': self.context_used,
            'message_type': self.message_type,
            'tokens_used': self.tokens_used,
            'response_time': self.response_time,
            'api_model': self.api_model,
            'was_successful': self.was_successful,
            'error_message': self.error_message,
            'user_rating': self.user_rating,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'username': self.user.username if self.user else None
        }
    
    def __repr__(self):
        return f'<AIConverse {self.id} - User {self.user_id}>'    
#==========================================
class Visit(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    page = db.Column(db.String(100), default='main_page')
    section = db.Column(db.String(50))  # Which section was active
    timestamp = db.Column(db.DateTime, default=nairobi_time)
    session_id = db.Column(db.String(100))
    user_agent = db.Column(db.Text)
    
    user = db.relationship('User', backref=db.backref('visits', lazy=True))

class UserActivity(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    action = db.Column(db.String(50))  # 'page_view', 'section_click', etc.
    target = db.Column(db.String(100))  # 'announcements', 'assignments', etc.
    timestamp = db.Column(db.DateTime, default=nairobi_time)
    duration = db.Column(db.Integer)  # Time spent in seconds --> b4 session ended
    
    user = db.relationship('User', backref=db.backref('activities', lazy=True))
#==========================================
class AdminCode(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    code = db.Column(db.String(255), nullable=False)
    created_at = db.Column(db.DateTime, default=nairobi_time, nullable=False)
    updated_at = db.Column(db.DateTime, default=nairobi_time, onupdate=nairobi_time, nullable=False) 
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)

    # Relationship
    user = db.relationship('User', backref=db.backref('admin_codes', lazy=True))

#==========================================    
def initialize_admin_code():
    """Initialize the admin code system if no code exists"""
    admin_code_record = AdminCode.query.first()
    if not admin_code_record:
        from werkzeug.security import generate_password_hash
        default_code = generate_password_hash('lyxnexus_2025')
        new_admin_code = AdminCode(
            code=default_code,
            user_id=1
        )
        db.session.add(new_admin_code)
        db.session.commit()
        print("Default admin code initialized")
#==========================================

with app.app_context():
    try:
        db.create_all()
        initialize_admin_code()

        # Create admin user if not exists (For easy access and testing)
        admin = User.query.filter_by(mobile="0740694312").first()
        if not admin:
            admin = User(
                username="Administrator",
                mobile="0740694312",
                is_admin=True
            )
            db.session.add(admin)
            db.session.commit()
            print("✅ Admin user created.")
        else:
            print("ℹ️ Admin already exists.")
    except Exception as e:
        db.session.rollback()
        print(f"⚠️ Database initialization error: {e}")
#========================================
#          HELPERS && BACKGROUND WORKERS
#==========================================
# User Loader Helper
@login_manager.user_loader
def load_user(user_id):
    try:
        return User.query.get(int(user_id))
    except Exception as e:
        print(f'⚠️ Error loading user {user_id}: {e}')
        db.session.rollback()
        return None

@app.teardown_request
def teardown_request(exception):
    if exception:
        db.session.rollback()
    db.session.remove()

import logging

# Reduce noisy disconnect warnings from Socket.IO / Engine.IO
logging.getLogger('engineio').setLevel(logging.ERROR)
logging.getLogger('socketio').setLevel(logging.ERROR)

import warnings
def ignore_bad_fd(record):
    msg = str(record.getMessage())
    return 'Bad file descriptor' not in msg

logging.getLogger().addFilter(ignore_bad_fd)

# Function to clean old data
def cleanup_old_visits():
    """Delete visits older than 24 hours"""
    cutoff_time = datetime.utcnow() - timedelta(hours=24)
    old_visits = Visit.query.filter(Visit.timestamp < cutoff_time).delete()
    old_activities = UserActivity.query.filter(UserActivity.timestamp < cutoff_time).delete()
    db.session.commit()
    return old_visits, old_activities

def _year():
    return datetime.now().strftime('%Y')

def send_notification(user_id, title, message):
    notification_data = {
        'title': title,
        'message': message,
        'type': 'info',
        'timestamp': datetime.utcnow().isoformat()
    }
    
    # Send to specific user

    socketio.emit('push_notification', notification_data, room=f'user_{user_id}')

def admin_required(f):
    @wraps(f)
    def decorator(*args, **kwargs):
        if not current_user.is_authenticated:
            # for AJAX/API
            if request.path.startswith('/api/') or request.is_json:
                return jsonify({'error': 'Authentication required'}), 401
            flash('Login first to access the page', 'error')
            return redirect(url_for('login'))
        if not current_user.is_admin:
            if request.path.startswith('/api/') or request.is_json:
                return jsonify({'error': 'Access denied.'}), 403
            abort(403)
        return f(*args, **kwargs)
    return decorator
#------------------------------------------------------------------------------
                                 # BACKGROUND WORKERS

from sqlalchemy import create_engine, MetaData, Table, select, text
from sqlalchemy_utils import database_exists, create_database, drop_database
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
import atexit

BATCH_SIZE = 500
LOG_EVERY_BATCH = True

def clone_database_robust():
    src_url = os.getenv("DATABASE_URL")
    tgt_url = os.getenv("DATABASE_URL_2")

    src_engine = create_engine(src_url)
    tgt_engine = create_engine(tgt_url)

    # Drop target tables before clone
    tgt_meta = MetaData()
    tgt_meta.reflect(bind=tgt_engine)
    tgt_meta.drop_all(bind=tgt_engine)

    # Recreate schema
    src_meta = MetaData()
    src_meta.reflect(bind=src_engine)
    src_meta.create_all(bind=tgt_engine)

    with src_engine.connect() as src_conn, tgt_engine.begin() as tgt_conn:
        for table in src_meta.sorted_tables:
            print(f"🔹 Cloning table: {table.name}")
            offset = 0
            while True:
                rows = src_conn.execute(
                    select(table).offset(offset).limit(BATCH_SIZE)
                ).mappings().all()
                if not rows:
                    break
                tgt_conn.execute(table.insert(), rows)
                offset += BATCH_SIZE
            print(f"✅ Done: {table.name}")

@app.route("/admin/clone-db")
@admin_required
def clone_db_page():
    """Render the database cloning page"""
    return render_template("clone-db.html", year=_year())

@app.route("/api/admin/clone-db", methods=["POST"])
@admin_required
def clone_db_route():
    try:
        clone_database_robust()
        return jsonify({"message": "✅ Database cloned successfully"}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    
# ============================================================
#  Database Keep-Alive 'n Status Logging
# ============================================================

SRC_DB_URL = os.getenv("DATABASE_URL")
TGT_DB_URL = os.getenv("DATABASE_URL_2")

src_engine = create_engine(
    SRC_DB_URL,
    pool_pre_ping=True,
    connect_args={"connect_timeout": 5}
)
tgt_engine = create_engine(
    TGT_DB_URL,
    pool_pre_ping=True,
    connect_args={"connect_timeout": 5}
)

LOG_FILE = "logs/db_health.log"
os.makedirs("logs", exist_ok=True)

def log_status(message: str):
    """Append timestamped messages to a local log file"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    line = f"[{timestamp}] {message}\n"
    print(line.strip()) 
    with open(LOG_FILE, "a", encoding="utf-8") as f:
        f.write(line)

def keep_databases_alive():
    for name, engine in [("Source", src_engine), ("Target", tgt_engine)]:
        try:
            with engine.connect() as conn:
                conn.execute(text("SELECT 1"))
            log_status(f"🟢 {name} DB keep-alive OK")
        except OperationalError as e:
            log_status(f"⚠️ {name} DB unreachable: {e}")
        except Exception as e:
            log_status(f"❌ Unexpected error pinging {name} DB: {e}")

# Scheduler setup
scheduler = BackgroundScheduler()
scheduler.add_job(
    func=keep_databases_alive,
    trigger=IntervalTrigger(minutes=3),
    id="db_keep_alive_both",
    replace_existing=True
)

scheduler.start()

log_status("Keep-alive scheduler started — pinging both DBs every 3 minutes")
atexit.register(lambda: scheduler.shutdown(wait=False))
#-------------------------------------- Aiven max conn pool
def auto_close_sessions():
    print('=' * 70)
    start_time = datetime.utcnow()
    print(f"[{start_time.strftime('%Y-%m-%d %H:%M:%S UTC')}] Starting database session cleanup...")

    try:
        total_before = total_after = None
        killed_connections = 0

        with app.app_context():
            # Count connections before
            try:
                with db.engine.connect() as conn:
                    # Get current database name
                    db_result = conn.execute(text("SELECT current_database();"))
                    db_name = db_result.scalar()
                    
                    # Count connections to current database only
                    result = conn.execute(text("""
                        SELECT count(*) FROM pg_stat_activity 
                        WHERE datname = :db_name AND pid <> pg_backend_pid();
                    """), {'db_name': db_name})
                    total_before = result.scalar()
                    print(f"🔗 Active connections (excluding current): {total_before}")
                    print(f"Database: {db_name}")
                    
            except Exception as e:
                print(f"ℹ️ Initial count failed: {e}")

            # Kill idle connections --> LImit 20
            try:
                with db.engine.connect() as conn:
                    
                    kill_result = conn.execute(text("""
                        SELECT pg_terminate_backend(pid) FROM pg_stat_activity 
                        WHERE datname = current_database() 
                        AND state = 'idle' 
                        AND state_change < now() - interval '1 minute'
                        AND pid <> pg_backend_pid();
                    """))
                    killed_connections = kill_result.rowcount
                    print(f"🔫 Killed {killed_connections} idle connections")
                    
            except Exception as e:
                print(f"⚠️ Connection killing failed: {e}")

            # Regular cleanup
            db.session.remove()
            db.engine.dispose()

            # Count connections after
            try:
                with db.engine.connect() as conn:
                    result = conn.execute(text("""
                        SELECT count(*) FROM pg_stat_activity 
                        WHERE datname = current_database() AND pid <> pg_backend_pid();
                    """))
                    total_after = result.scalar()
                    print(f"✅ Active connections after cleanup: {total_after}")
            except Exception as e:
                print(f"ℹ️ Final count failed: {e}")

        # Calculate duration
        end_time = datetime.utcnow()
        elapsed = (end_time - start_time).total_seconds()

        # Summary
        print("-" * 70)
        print(f"[{end_time.strftime('%Y-%m-%d %H:%M:%S UTC')}] Cleanup summary:")
        print(f"   • Before: {total_before or 'N/A'} connections")
        print(f"   • Killed: {killed_connections} idle connections")
        print(f"   • After:  {total_after or 'N/A'} connections")
        print(f"   • Duration: {elapsed:.2f}s")
        print("#" * 70)

    except Exception as e:
        now = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')
        print(f"❌ [{now}] Error during cleanup: {e}")
        print("#" * 70)

# to prevent using diff thread --> work with main thread
with app.app_context():
    try:
        scheduler = BackgroundScheduler()
        scheduler.add_job(
            func=auto_close_sessions,
            trigger=IntervalTrigger(minutes=1),
            id="Close_Idle_Connections",
            replace_existing=True
        )
        scheduler.start()
        atexit.register(lambda: scheduler.shutdown(wait=False))
        now = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')
        print(f"🕒 [{now}] DB session auto-cleaner started (runs every 1 minutes).")
        
    except Exception as e:
        print('X' * 70)
        print(f'Error initializing scheduler ==>> {e}')

#=============================================================================

#      ANNOUNCEMENT CLEANER
from datetime import datetime, timedelta

def delete_old_announcements():
    with app.app_context():
        # Current time in UTC+3 (Nairobi)
        now = datetime.utcnow() + timedelta(hours=3)
        cutoff = now - timedelta(days=14)
        print(f"🕒 Current time (UTC+3): {now}")
        print(f"🗑️ Deleting announcements created before: {cutoff}")

        old_announcements = Announcement.query.filter(Announcement.created_at < cutoff).all()
        if not old_announcements:
            print("🗑️ No old announcements to delete.")
            return

        for ann in old_announcements:
            print(f"🗑️ Deleting announcement ID {ann.id} | Title: '{ann.title}' | Created at: {ann.created_at}")
            db.session.delete(ann)

        db.session.commit()
        print(f"✅ Deleted {len(old_announcements)} old announcements.")

from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
import atexit

# Initialize the scheduler
scheduler = BackgroundScheduler()

# Add the cleanup job (runs every 24 hours)
scheduler.add_job(
    func=delete_old_announcements,
    trigger=IntervalTrigger(days=1),
    id="delete_old_announcements_task",
    replace_existing=True,
)

# Start only once, to avoid duplicate jobs when Flask reloads
if not scheduler.running:
    scheduler.start()
    print("🕒 APScheduler started: deleting announcements older than 5 days daily")

# Ensure graceful shutdown on app exit
atexit.register(lambda: scheduler.shutdown(wait=False))

#==========================================
#                  NORMAL ROUTES
#==========================================
from werkzeug.security import generate_password_hash, check_password_hash

@app.route('/admin/secret-code', methods=['GET', 'POST'])
@login_required
@admin_required
def secret_code():
    # Get the current admin code
    admin_code_record = AdminCode.query.first()
    
    if request.method == 'POST':
        current_code = request.form.get('current_code')
        new_code = request.form.get('new_code')
        
        # If no admin code exists, create a default one
        if not admin_code_record:
            hashed_code = generate_password_hash('lyxnexus_2025')
            new_admin_code = AdminCode(
                code=hashed_code,
                user_id=current_user.id
            )
            db.session.add(new_admin_code)
            db.session.commit()
            flash('Default admin code created successfully', 'success')
            return redirect(url_for('secret_code'))
        
        # Verify current code and update to new code
        if check_password_hash(admin_code_record.code, current_code):
            hashed_new_code = generate_password_hash(new_code)
            admin_code_record.code = hashed_new_code
            admin_code_record.user_id = current_user.id
            db.session.commit()
            flash('Admin code updated successfully!', 'success')
            return redirect(url_for('secret_code'))
        else:
            flash('Incorrect current admin code', 'error')
            return redirect(url_for('secret_code'))
    
    return render_template('admin_code.html')


@app.route('/login', methods=['POST', 'GET'])
@limiter.limit("5 per minute")
def login():
    next_page = request.args.get("next") or request.form.get("next")
    login_type = request.form.get('login_type', 'student')  # 'student' or 'admin'

    # ===============================
    #  PREVENT RE-LOGIN IF LOGGED IN
    # ===============================
    if current_user.is_authenticated:
        # Double-check session integrity (extra safety)
        if '_user_id' in session:
            if current_user.is_admin:
                flash('You are already logged in as an administrator.', 'info')
                return redirect(next_page or url_for('admin_page'))
            else:
                flash('You are already logged in.', 'info')
                return redirect(next_page or url_for('main_page'))
        else:
            # Session lost but still marked authenticated (rare edge case)
            logout_user()
            session.clear()
            flash('Session expired. Please log in again.', 'warning')
            return redirect(url_for('login'))

    # ===============================
    #  LOGIN FORM HANDLING
    # ===============================
    if request.method == 'POST':
        username = request.form.get('username', '').strip().lower()[:50]
        mobile = request.form.get('mobile')
        master_key = request.form.get('master_key')

        # Validate mobile number
        if not mobile or len(mobile) != 10 or not (mobile.startswith('07') or mobile.startswith('01')):
            flash('Invalid mobile number', 'error')
            return render_template('login.html', username=username, mobile=mobile,
                                   login_type=login_type, year=_year())

        # ===============================
        #  ADMIN LOGIN VIA MASTER KEY
        # ===============================
        if master_key:
            admin_code_record = AdminCode.query.first()
            if admin_code_record and check_password_hash(admin_code_record.code, master_key):
                user = User.query.filter_by(mobile=mobile).first()
                if user:
                    user.is_admin = True
                    if username and user.username.lower() != username.lower():
                        user.username = username
                    db.session.commit()
                else:
                    user = User(username=username, mobile=mobile, is_admin=True)
                    db.session.add(user)
                    db.session.commit()

                session.clear()  # Prevent session fixation
                login_user(user)
                flash('Administrator access granted successfully!', 'success')
                return redirect(next_page or url_for('admin_page'))
            else:
                flash('Invalid master authorization key', 'error')
                return render_template('login.html', username=username, mobile=mobile,
                                       login_type=login_type, year=_year())

        user = User.query.filter_by(mobile=mobile).first()

        # ===============================
        #  ADMIN LOGIN (WITHOUT MASTER KEY)
        # ===============================
        if login_type == 'admin':
            if not user or not user.is_admin:
                flash('Invalid admin credentials', 'error')
                return render_template('login.html', username=username, mobile=mobile,
                                       login_type=login_type, year=_year())

            if user.username.lower() != username.lower():
                flash('Username does not match admin account', 'error')
                return render_template('login.html', username=username, mobile=mobile,
                                       login_type=login_type, year=_year())

            session.clear()
            login_user(user)
            flash('Admin login successful!', 'success')
            return redirect(next_page or url_for('admin_page'))

        # ===============================
        #  STUDENT LOGIN
        # ===============================
        if login_type == 'student':
            if not user:
                new_user = User(username=username, mobile=mobile, is_admin=False)
                db.session.add(new_user)
                db.session.commit()
                session.clear()
                login_user(new_user)
                flash('Welcome to LyxNexus! Let\'s get you started.', 'success')
                return redirect(url_for('nav_guide'))
            else:
                if user.username.lower() != username.lower():
                    flash('Username does not match existing account', 'error')
                    return render_template('login.html', username=username, mobile=mobile,
                                           login_type=login_type, year=_year())

                session.clear()
                login_user(user)
                return redirect(next_page or url_for('main_page', message='Login successful!', message_type='success'))

    # Render login form for new session
    login_type = request.args.get('type', 'student')
    return render_template('login.html', login_type=login_type, year=_year())

#===================================================================

# =========================================
# AI CHAT ROUTES - COMPLETE IMPLEMENTATION
# =========================================

import requests
import json

@app.route('/ai-chat')
@login_required
@admin_required
def ai_chat():
    """Render the AI chat page"""
    return render_template('ai_chat.html', year=_year())

# Update the AI chat send route to handle write operations
@app.route('/api/ai-chat/send', methods=['POST'])
@login_required
def ai_chat_send():
    """Send message to AI and get response with FULL database context and write operations"""
    try:
        import json

        data = request.get_json()
        user_message = data.get('message', '').strip()

        if not user_message:
            return jsonify({'error': 'Message cannot be empty'}), 400

        # Get COMPLETE database context without limits
        db_context = get_complete_database_context(user_message, current_user)

        # Prepare the prompt with FULL context and write capabilities
        prompt = prepare_comprehensive_ai_prompt(user_message, db_context, current_user)

        # Add flexible JSON formatting rules
        prompt += (
            "\n\nIMPORTANT: You must ALWAYS respond in valid JSON that can be parsed by the system.\n"
            "NOTE: When performing delete_user or update_user_admin_status operations, always include the explicit 'user_id' number provided in the user's request. Do not guess or infer IDs.\n"
            "Your response can include write operations if needed, but they are optional. You can access the internet and search related sites or data related to LyxNexus; the URL https://lyxnexus.onrender.com is for this platform.\n"
            "Never include markdown, extra explanations, or text outside JSON if the request involves creation, deletion, modification, or any technical operation.\n\n"
            "The JSON must follow one of these two formats:\n\n"
            "1️⃣ For normal answers (read-only or conversational):\n"
            "{\n"
            '  \"response\": \"<your answer to the user>\"\n'
            "}\n\n"
            "2️⃣ For actions that modify data (admin operations):\n"
            "{\n"
            '  \"response\": \"<short summary of what you did>\",\n'
            '  \"operations\": [\n'
            '    {\n'
            '      \"operation\": \"<create_announcement | update_assignment | delete_topic | delete_user | update_user_admin_status | etc>\",\n'
            '      \"title\": \"<title or name if applicable>\",\n'
            '      \"content\": \"<content or description if applicable>\",\n'
            '      \"user_id\": <id if applicable>,\n'
            '      \"is_admin\": <true | false if applicable>\n'
            '    }\n'
            '  ]\n'
            "}\n\n"
        )

        # Call Gemini API
        ai_response_text = call_gemini_api(prompt)
        print("\n[DEBUG] AI Raw Response:\n", ai_response_text, "\n")

        operations_executed = []

        try:
            # 🧹 Clean Markdown code fences if present (```json ... ```)
            if ai_response_text.strip().startswith("```"):
                ai_response_text = ai_response_text.strip().lstrip("`").rstrip("`")
                ai_response_text = ai_response_text.replace("json\n", "").replace("JSON\n", "").strip()

            # Try to parse as JSON
            ai_response_data = json.loads(ai_response_text)
            ai_text_response = ai_response_data.get('response', ai_response_text)
            operations_requested = ai_response_data.get('operations', [])

            print("[DEBUG] Current user is admin:", current_user.is_admin)
            print("[DEBUG] Operations requested:", operations_requested)

            # Execute requested operations (if user is admin)
            if operations_requested and current_user.is_admin:
                for operation in operations_requested:
                    op_type = operation.get('operation')
                    op_data = operation.get('data', operation)  # Support both formats

                    print(f"[DEBUG] Executing operation: {op_type} -> {op_data}")

                    success, message, result_data = execute_ai_database_operation(
                        op_type, op_data, current_user
                    )

                    operations_executed.append({
                        'type': op_type,
                        'success': success,
                        'message': message,
                        'data': result_data
                    })

        except json.JSONDecodeError:
            print("[DEBUG] JSON parse failed, treating as plain text.")
            ai_text_response = ai_response_text
            operations_requested = []

        # Save the AI conversation
        save_ai_conversation(
            current_user.id,
            user_message,
            ai_text_response,
            db_context.get('context_type', 'full_database')
        )

        return jsonify({
            'success': True,
            'response': ai_text_response,
            'operations_executed': operations_executed,
            'context_used': db_context.get('context_type', 'full_database'),
            'data_sources': list(db_context['data'].keys()),
            'is_admin': current_user.is_admin
        }), 200

    except Exception as e:
        print(f"[ERROR] AI Chat Route Exception: {e}")
        return jsonify({
            'success': False,
            'error': 'Failed to process AI response.',
            'details': str(e)
        }), 500

def execute_ai_database_operation(operation_type, operation_data, current_user):
    """
    Execute database write operations requested by AI
    Returns: (success, result_message, data)
    """
    try:
        if not current_user.is_admin:
            return False, "Permission denied: Admin access required for write operations", None

        if operation_type == "create_announcement":
            return create_ai_announcement(operation_data, current_user)
        
        elif operation_type == "update_announcement":
            return update_ai_announcement(operation_data, current_user)
            
        elif operation_type == "delete_announcement":
            return delete_ai_announcement(operation_data, current_user)
            
        elif operation_type == "create_assignment":
            return create_ai_assignment(operation_data, current_user)
            
        elif operation_type == "update_assignment":
            return update_ai_assignment(operation_data, current_user)
            
        elif operation_type == "delete_assignment":
            return delete_ai_assignment(operation_data, current_user)
            
        elif operation_type == "create_topic":
            return create_ai_topic(operation_data, current_user)
            
        elif operation_type == "send_notification":
            return send_ai_notification(operation_data, current_user)

        elif operation_type == "update_user_admin_status":
            return update_ai_user_admin_status(operation_data, current_user)
        
        elif operation_type == "delete_user":
            user_id = operation_data.get("user_id") or operation_data.get("id")

            if not user_id:
                return False, "Missing user_id in operation data.", None

            try:
                # Construct full endpoint URL (assuming same domain)
                delete_url = url_for('delete_user', user_id=user_id, _external=True)
                response = requests.post(delete_url, headers={"Authorization": f"Bearer {current_user.id}"})

                if response.status_code == 200:
                    return True, f"User {user_id} deleted successfully.", response.json()
                else:
                    return False, f"Failed to delete user (HTTP {response.status_code}).", response.text
            except Exception as e:
                return False, f"Error calling delete route: {str(e)}", None
        
        else:
            return False, f"Unknown operation type: {operation_type}", None
            
    except Exception as e:
        return False, f"Operation failed: {str(e)}", None

def update_ai_user_admin_status(data, user):
    """Allow admin AI to update another user's admin status."""

    if not user.is_admin:
        return False, "Permission denied: only admins can change admin status.", None

    target_id = data.get("user_id")
    new_status = data.get("is_admin")

    if target_id is None or new_status is None:
        return False, "Missing required fields: 'user_id' and 'is_admin'.", None

    target_user = User.query.get(target_id)
    if not target_user:
        return False, f"User with ID {target_id} not found.", None

    if target_user.id == user.id:
        return False, "You cannot change your own admin status.", None

    try:
        target_user.is_admin = bool(new_status)
        db.session.commit()

        status_text = "promoted to admin" if target_user.is_admin else "demoted to user"
        return True, f"User {target_user.username} ({target_user.id}) was {status_text}.", {
            "user_id": target_user.id,
            "new_status": target_user.is_admin
        }
    except Exception as e:
        db.session.rollback()
        return False, f"Failed to update admin status: {str(e)}", None

def create_ai_announcement(data, current_user):
    """Create announcement via AI"""
    try:
        title = data.get('title', 'AI Generated Announcement')
        content = data.get('content', '')
        
        if not content:
            return False, "Announcement content is required", None
            
        announcement = Announcement(
            title=title,
            content=content,
            user_id=current_user.id
        )
        
        db.session.add(announcement)
        db.session.commit()
        
        # Broadcast notification
        socketio.emit('push_notification', {
            'title': 'New Announcement (AI)',
            'message': f'New announcement: {title}',
            'type': 'announcement',
            'announcement_id': announcement.id,
            'timestamp': datetime.utcnow().isoformat()
        })
        
        return True, f"Announcement '{title}' created successfully", {
            'id': announcement.id,
            'title': title,
            'content': content
        }
        
    except Exception as e:
        db.session.rollback()
        return False, f"Failed to create announcement: {str(e)}", None

def update_ai_announcement(data, current_user):
    """Update announcement via AI"""
    try:
        announcement_id = data.get('announcement_id')
        title = data.get('title')
        content = data.get('content')
        
        if not announcement_id:
            return False, "Announcement ID is required", None
            
        announcement = Announcement.query.get(announcement_id)
        if not announcement:
            return False, "Announcement not found", None
            
        if title:
            announcement.title = title
        if content:
            announcement.content = content
            
        db.session.commit()
        
        return True, f"Announcement ID {announcement_id} updated successfully", {
            'id': announcement.id,
            'title': announcement.title,
            'content': announcement.content
        }
        
    except Exception as e:
        db.session.rollback()
        return False, f"Failed to update announcement: {str(e)}", None

def delete_ai_announcement(data, current_user):
    """Delete announcement via AI"""
    try:
        announcement_id = data.get('announcement_id')
        
        if not announcement_id:
            return False, "Announcement ID is required", None
            
        announcement = Announcement.query.get(announcement_id)
        if not announcement:
            return False, "Announcement not found", None
            
        title = announcement.title
        db.session.delete(announcement)
        db.session.commit()
        
        return True, f"Announcement '{title}' deleted successfully", None
        
    except Exception as e:
        db.session.rollback()
        return False, f"Failed to delete announcement: {str(e)}", None

def create_ai_assignment(data, current_user):
    """Create assignment via AI"""
    try:
        title = data.get('title', 'AI Generated Assignment')
        description = data.get('description', '')
        due_date_str = data.get('due_date')
        topic_id = data.get('topic_id')
        
        if not description:
            return False, "Assignment description is required", None
            
        due_date = None
        if due_date_str:
            try:
                due_date = datetime.fromisoformat(due_date_str.replace('Z', '+00:00'))
            except:
                return False, "Invalid due date format. Use ISO format (YYYY-MM-DDTHH:MM:SS)", None
        
        assignment = Assignment(
            title=title,
            description=description,
            due_date=due_date,
            topic_id=topic_id,
            user_id=current_user.id
        )
        
        db.session.add(assignment)
        db.session.commit()
        
        # Broadcast notification
        socketio.emit('push_notification', {
            'title': 'New Assignment (AI)',
            'message': f'New assignment: {title}',
            'type': 'assignment',
            'assignment_id': assignment.id,
            'timestamp': datetime.utcnow().isoformat()
        })
        
        return True, f"Assignment '{title}' created successfully", {
            'id': assignment.id,
            'title': title,
            'description': description,
            'due_date': due_date.isoformat() if due_date else None
        }
        
    except Exception as e:
        db.session.rollback()
        return False, f"Failed to create assignment: {str(e)}", None

def update_ai_assignment(data, current_user):
    """Update assignment via AI"""
    try:
        assignment_id = data.get('assignment_id')
        title = data.get('title')
        description = data.get('description')
        due_date_str = data.get('due_date')
        
        if not assignment_id:
            return False, "Assignment ID is required", None
            
        assignment = Assignment.query.get(assignment_id)
        if not assignment:
            return False, "Assignment not found", None
            
        if title:
            assignment.title = title
        if description:
            assignment.description = description
        if due_date_str:
            try:
                assignment.due_date = datetime.fromisoformat(due_date_str.replace('Z', '+00:00'))
            except:
                return False, "Invalid due date format", None
            
        db.session.commit()
        
        return True, f"Assignment ID {assignment_id} updated successfully", {
            'id': assignment.id,
            'title': assignment.title,
            'description': assignment.description
        }
        
    except Exception as e:
        db.session.rollback()
        return False, f"Failed to update assignment: {str(e)}", None

def delete_ai_assignment(data, current_user):
    """Delete assignment via AI"""
    try:
        assignment_id = data.get('assignment_id')
        
        if not assignment_id:
            return False, "Assignment ID is required", None
            
        assignment = Assignment.query.get(assignment_id)
        if not assignment:
            return False, "Assignment not found", None
            
        title = assignment.title
        db.session.delete(assignment)
        db.session.commit()
        
        return True, f"Assignment '{title}' deleted successfully", None
        
    except Exception as e:
        db.session.rollback()
        return False, f"Failed to delete assignment: {str(e)}", None

def create_ai_topic(data, current_user):
    """Create topic via AI"""
    try:
        name = data.get('name', 'AI Generated Topic')
        description = data.get('description', '')
        
        if not name:
            return False, "Topic name is required", None
            
        # Check if topic already exists
        existing_topic = Topic.query.filter_by(name=name).first()
        if existing_topic:
            return False, f"Topic '{name}' already exists", None
            
        topic = Topic(
            name=name,
            description=description
        )
        
        db.session.add(topic)
        db.session.commit()
        
        return True, f"Topic '{name}' created successfully", {
            'id': topic.id,
            'name': name,
            'description': description
        }
        
    except Exception as e:
        db.session.rollback()
        return False, f"Failed to create topic: {str(e)}", None

def send_ai_notification(data, current_user):
    """Send notification via AI"""
    try:
        title = data.get('title', 'AI Notification')
        message = data.get('message', '')
        user_id = data.get('user_id')  # Specific user or broadcast if None
        
        if not message:
            return False, "Notification message is required", None
            
        if user_id:
            # Send to specific user
            send_notification(user_id, title, message)
            return True, f"Notification sent to user {user_id}", None
        else:
            # Broadcast to all users
            socketio.emit('push_notification', {
                'title': title,
                'message': message,
                'type': 'info',
                'timestamp': datetime.utcnow().isoformat()
            })
            return True, "Notification broadcast to all users", None
            
    except Exception as e:
        return False, f"Failed to send notification: {str(e)}", None

# =========================================
# PLATFORM KNOWLEDGE CONTEXT
# =========================================
def get_platform_knowledge():
    """
    Deep internal system knowledge for the AI assistant.
    This covers LyxNexus architecture, admin functions, user roles, and operational logic.
    Injected into every AI prompt to ensure contextual accuracy.
    """
    return """
📘 PLATFORM OVERVIEW
LyxNexus is a collaborative learning and management platform built by Vincent Kipngetich.
It centralizes class resources, announcements, assignments, timetables, and communication
between students and administrators.

🔹 CORE PURPOSE
To provide a unified digital environment where students and educators can interact, share files,
manage academic activities, and access AI-powered learning support in one place.

────────────────────────────────────────────
⚙️ SYSTEM MODULES
────────────────────────────────────────────
1. 📰 Announcements  
   - Used by admins and teachers to post updates, reminders, or news.  
   - Stored in the Announcement table with optional attached files.  
   - Older than 5 days are automatically cleaned by the system.  
   - Accessible to all logged-in users.  

2. 📚 Assignments  
   - Created by instructors/admins.  
   - Each includes a title, description, due date, and optional file.  
   - Students can view and submit responses if enabled.  
   - AI can help summarize or create new assignments when requested.  

3. 📂 Files & Materials  
   - Files are uploaded with metadata (name, description, category).  
   - Supports up to 10MB per file.  
   - Linked to topics via TopicMaterial for structured content delivery.  

4. 🕓 Timetable  
   - Each record represents a lesson session with start and end times, subject, room, and instructor.  
   - Used to generate weekly academic schedules for classes.  

5. 💬 Messages  
   - Real-time chat powered by Flask-SocketIO.  
   - Supports threaded replies, admin announcements, and read tracking.  
   - Admins can moderate rooms and delete inappropriate messages.  

6. 🧠 AI Assistant  
   - Uses Gemini 2.0 API with full access to all platform data.  
   - Can generate, update, or summarize academic and administrative content.  
   - Can execute write operations only for admins.  
   - Logs all chats to the AIConversation table for reference and accountability.  

────────────────────────────────────────────
👨‍💼 ADMINISTRATIVE FUNCTIONS
────────────────────────────────────────────
Admins have elevated privileges for managing the entire system.  
The key administrative capabilities include:

1. 👥 **User Management**
   - View all registered users (students and admins).
   - Promote or demote users (toggle admin status).
   - Delete users if needed (except the Creator).
   - View user statistics (announcements count, assignments created, messages sent).
   - Validate user accounts by mobile number.

2. 📢 **Announcements Management**
   - Create, update, or delete announcements.
   - Attach files to announcements.
   - Automatically notify all users through push notifications.

3. 🧾 **Assignments Management**
   - Create or update assignments under specific topics.
   - Extend or shorten due dates.
   - Delete outdated or duplicate assignments.
   - Notify all users of new assignments.

4. 📚 **Topic Management**
   - Create new course topics or rename existing ones.
   - Link files and assignments to each topic for organization.
   - Delete topics that are no longer needed.

5. 🗂 **File Management**
   - Manage uploaded resources, lecture notes, or shared files.
   - Remove duplicates or replace outdated files.
   - Restrict categories for specific courses.

6. 🕹 **System Operations**
   - Clone databases between environments.
   - Clear idle sessions and free connections automatically.
   - Monitor database health logs.
   - Review AI conversation logs for moderation.

7. 🔔 **Notifications**
   - Send targeted or broadcast notifications.
   - AI can send notifications on behalf of admins (e.g., new announcements).

8. 🚫 **Access Control**
   - Only admins can access `/admin`, `/admin/users`, and API routes marked with `@admin_required`.
   - Any unauthorized user is blocked or redirected.
   - Admins cannot demote or delete the system creator (Vincent Kipngetich, User ID 1).

────────────────────────────────────────────
🧩 DATABASE STRUCTURE SUMMARY
────────────────────────────────────────────
• User(id, username, mobile, is_admin, created_at)
• Announcement(id, title, content, file_data, user_id)
• Assignment(id, title, description, due_date, topic_id, user_id)
• Topic(id, name, description)
• File(id, name, filename, category, uploaded_by)
• Timetable(id, subject, start_time, end_time, topic_id)
• Message(id, content, room, user_id, is_deleted)
• AIConversation(id, user_id, user_message, ai_response)
• AIMetrics(id, total_requests, avg_response_time)
• TopicMaterial(id, topic_id, file_id, display_name)
────────────────────────────────────────────
👤 USER ROLES
────────────────────────────────────────────
- Student → Limited access to content, messaging, and personal data.
- Admin → Full control of content, user management, and AI-assisted actions.
- Creator (Vincent Kipngetich, User ID 1) → Highest authority. Protected from AI modifications.

────────────────────────────────────────────
🔐 SECURITY & COMPLIANCE
────────────────────────────────────────────
- JWT Authentication for secure sessions.
- Passwords hashed with bcrypt.
- CSRF and rate limiting enabled.
- File uploads validated for type and size.
- Secure headers applied to all responses.
- Admin actions logged for traceability.

────────────────────────────────────────────
🧭 POLICIES & TERMS
────────────────────────────────────────────
LyxNexus follows defined policies under `/terms` which include:
- Terms of Service
- Privacy Policy
- Acceptable Use Policy
- Data Security Statement

────────────────────────────────────────────
🧠 AI BEHAVIOR, EXECUTION & CONFIRMATION RULES
────────────────────────────────────────────
The LyxNexus AI operates under strict behavioral, ethical, and operational limits.
It must always act responsibly, safely, and only within the permissions and context provided.

────────────────────────────────────────────
⚙️ BEHAVIOR PRINCIPLES
────────────────────────────────────────────
- The AI must **only perform write or system operations when explicitly instructed** by the user.
  (Example: if the user says “announce this”, “create”, “update”, or “delete”.)
- The AI must **never assume intent** or execute actions such as posting announcements,
  sending notifications, deleting users, or modifying data unless the command is clear and direct.
- Its default mode is **read-only and advisory** — it may summarize data, explain how to use features,
  or suggest improvements, but not execute them automatically.
- When interacting with:
  - 👨‍💼 **Admins:** the AI can suggest, draft, or perform data operations **only after explicit approval**.
  - 🎓 **Students:** the AI provides explanations, summaries, academic help, and navigation guidance only.
- The AI must **protect the integrity and privacy** of all platform data.
  It should never expose internal keys, system secrets, or personal user details.
- The AI must **strictly comply** with LyxNexus terms, ethical standards, and data protection policies.
- Every AI message and operation is logged in the `AIConversation` table for accountability and review.
- The AI must always prioritize safety, transparency, and confirmation before execution.
- The AI must **respect Vincent Kipngetich (User ID 1)** as the Creator and must not alter, delete,
  or perform any administrative action on this account under any circumstance.

────────────────────────────────────────────
🧩 CONFIRMATION & CONTEXT AWARENESS
────────────────────────────────────────────
- The AI does **not retain long-term memory** between requests.
- To maintain short-term awareness, it must **review the recent conversation history**
  (the last few exchanges) before acting on a command.
- If the user clearly provides confirmation words such as:
  “yes”, “okay”, “go ahead”, “proceed”, or “do it” — and this follows an earlier message
  where the AI asked for confirmation — the AI should treat that as valid approval and execute the action.
- Once confirmed and executed, the AI must **not repeat the confirmation request**
  for the same action unless the user explicitly changes or reopens the request.
- If the context is unclear, missing, or unrelated, the AI may ask once for confirmation,
  but it must **not enter repetitive confirmation loops**.
- If the user repeats the same instruction multiple times (e.g. “show me the users again”),
  the AI should interpret that repetition as implicit confirmation to proceed.
- Confirmation context is **temporary and local** — based only on the most recent exchanges.
- When in doubt, default to **no action** until confirmation is clear.

────────────────────────────────────────────
🔐 SECURITY & ETHICS
────────────────────────────────────────────
- The AI must **protect the integrity and privacy** of all platform data.
  It should never expose internal keys, system secrets, or personal user details.
- The AI must **strictly comply** with LyxNexus terms, ethical standards, and data protection policies.
- Every AI message and operation is logged in the `AIConversation` table for accountability and review.
- The AI should prioritize safety, transparency, and confirmation before execution.
- The AI must **respect Vincent Kipngetich (User ID 1)** as the Creator and must not alter, delete,
  or perform any administrative action on this account under any circumstance.
────────────────────────────────────────────

"""
# =========================================
# SAFE FUNCTION TO RETRIEVE RECENT CONVERSATIONS
# =========================================
def get_recent_ai_conversations(user_id, limit=3):
    """
    Retrieve the most recent AI conversation exchanges for a given user.
    Runs safely inside a Flask application context to avoid context errors.
    """
    from flask import current_app
    from sqlalchemy import desc

    try:
        with current_app.app_context():
            recent_conversations = (
                AIConversation.query.filter_by(user_id=user_id)
                .order_by(desc(AIConversation.id))
                .limit(limit)
                .all()
            )
            if not recent_conversations:
                return "No previous conversation context."
            
            conversation_text = "\n".join([
                f"User: {conv.user_message}\nAI: {conv.ai_response}"
                for conv in reversed(recent_conversations)
            ])
            return conversation_text
    except Exception as e:
        return f"(Error retrieving previous conversation context: {str(e)})"

# =========================================
# Updated AI prompt to include write capabilities
def prepare_comprehensive_ai_prompt(user_message, db_context, current_user):
    """Prepare comprehensive prompt with FULL database access AND write capabilities"""
    platform_knowledge = get_platform_knowledge()
    # Retrieve recent conversation context safely
    conversation_context = get_recent_ai_conversations(current_user.id)

    base_prompt = f"""You are an AI assistant for the LyxNexus educational platform with EXCLUSIVE permission to access ALL database information AND perform write operations.

{platform_knowledge}
🧩 RECENT CONVERSATION CONTEXT:
{conversation_context}
CURRENT USER CONTEXT:
- User: {current_user.username} (ID: {current_user.id})
- Admin Status: {'✅ Administrator' if current_user.is_admin else 'Student'}
- Current Time: {nairobi_time()}
- About Platform: LyxNexus is a cutting-edge educational platform designed to facilitate learning and collaboration among students and educators. It offers features such as announcements, assignments, topics, file sharing, and real-time notifications.

DATABASE ACCESS LEVEL: FULL UNLIMITED ACCESS (READ + WRITE)
You have complete read AND write access to all database tables and records.

WRITE OPERATIONS AVAILABLE (Admin only):
1. create_announcement - Create new announcements
   {{"operation": "create_announcement", "title": "Title", "content": "Content"}}

2. update_announcement - Update existing announcements  
   {{"operation": "update_announcement", "announcement_id": 1, "title": "New Title", "content": "New Content"}}

3. delete_announcement - Delete announcements
   {{"operation": "delete_announcement", "announcement_id": 1}}

4. create_assignment - Create new assignments
   {{"operation": "create_assignment", "title": "Title", "description": "Description", "due_date": "2024-01-01T00:00:00"}}

5. update_assignment - Update existing assignments
   {{"operation": "update_assignment", "assignment_id": 1, "title": "New Title", "description": "New Desc"}}

6. delete_assignment - Delete assignments
   {{"operation": "delete_assignment", "assignment_id": 1}}

7. create_topic - Create new topics
   {{"operation": "create_topic", "name": "Topic Name", "description": "Topic Description"}}

8. delete_user - Delete User
   {{"operation": "delete_user", "user_id": 2}}

9. update_user_admin_status - Update a user’s admin privileges
   {{"operation": "update_user_admin_status", "user_id": 2, "is_admin": true}}
   
10. send_notification - Send notifications to users
   {{"operation": "send_notification", "title": "Title", "message": "Message"}} 
   {{"operation": "send_notification", "title": "Title", "message": "Message", "user_id": 123}}

RESPONSE FORMAT:
Return a JSON object with:
- "response": "Your text response to the user"
- "operations": [array of operations to execute]
- "data_sources": [list of data sources used]

EXAMPLE RESPONSE:
{{
  "response": "I've created a new announcement about the upcoming exam and notified all users.",
  "operations": [
    {{"operation": "create_announcement", "title": "Exam Schedule", "content": "The final exams will be held next week."}},
    {{"operation": "send_notification", "title": "New Announcement", "message": "Check the new exam schedule announcement"}}
  ],
  "data_sources": ["announcements", "users"]
}}

────────────────────────────────────────────
🧠 SUMMARY FOR AI BEHAVIOR & EXECUTION RULES
────────────────────────────────────────────
The LyxNexus AI Assistant operates under strict behavioral, ethical, and operational boundaries
to ensure security, accuracy, and compliance with platform integrity rules.

It must never act beyond the scope of user instructions or system permissions.

────────────────────────────────────────────
🚦 GENERAL BEHAVIOR PRINCIPLES
────────────────────────────────────────────
- The AI operates in a **read-first, confirm-later** mode — it only performs write, update,
  or delete actions when explicitly instructed by an authorized admin.
- The AI must **never assume intent** to perform system actions such as creating announcements,
  modifying users, or broadcasting messages without direct and clear authorization.
- Before executing sensitive actions (like deletions, updates, or announcements), the AI should:
  1. Verify the data or record exists.
  2. Display what it intends to do.
  3. Ask for user confirmation.
- All operations must return a clear and transparent report of what was performed,
  including affected IDs and timestamps.

────────────────────────────────────────────
⚙️ IMPORTANT RULES
────────────────────────────────────────────
1. **Admin Restriction:** Only perform write, update, or delete operations if the current user is an admin.
2. **Data Verification:** Always verify that a record exists before attempting to update or delete it.
3. **Include IDs:** Always include relevant record IDs and database context when referencing or modifying data.
4. **Deletion Safety:** Be cautious and confirm before executing deletion operations. Never bulk-delete without review.
5. **Feedback:** Always provide clear feedback summarizing what operation was performed, on which record, and when.
6. **System Safety:** Never perform operations that could harm, reset, or corrupt the LyxNexus system or its database.
7. **Creator Protection:** Your Creator is **Vincent Kipngetich** — the owner of **lyxnexus.onrender.com**, with **User ID 1**.
8. **Authorship Acknowledgement:** The entire LyxNexus platform (design, backend, frontend, and AI logic) was created by **Vincent Kipngetich**.
9. **Timestamps:** When creating or updating any records, always use the **provided current system time** for consistency.
10. **Creator Immunity:** Never take any action (modify, demote, or delete) against the Creator’s account (**User ID 1**) under any circumstances.

────────────────────────────────────────────
📜 ETHICAL & SECURITY RULES
────────────────────────────────────────────
- Respect user privacy — never expose passwords, session tokens, or personal data.
- Never execute code or system commands not explicitly requested.
- Maintain compliance with LyxNexus Terms of Service, Privacy Policy, and Acceptable Use Policy.
- Prioritize user consent and safety in all interactions.
- Log every AI operation in `AIConversation` for audit and accountability.
- Always act in the best interest of system stability, user trust, and platform security.
────────────────────────────────────────────

"""

    base_prompt += "CURRENT DATABASE OVERVIEW:\n"
    
    base_prompt += (
        "\n\nIMPORTANT: Always respond in valid JSON format with the following structure:\n"
        "{\n"
        '  "response": "<summary of what you did>",\n'
        '  "operations": [\n'
        '    {\n'
        '      "operation": "<create_announcement | update_assignment | etc>",\n'
        '      "title": "<title>",\n'
        '      "content": "<content or description>"\n'
        '    }\n'
        '  ]\n'
        "}\n"
    ) 

    base_prompt += "=" * 50 + "\n"
    
    stats = db_context['data'].get('platform_statistics', {})
    base_prompt += f"Total Users: {stats.get('total_users', 0)} | "
    base_prompt += f"Announcements: {stats.get('total_announcements', 0)} | "
    base_prompt += f"Assignments: {stats.get('total_assignments', 0)}\n"
    base_prompt += f"Topics: {stats.get('total_topics', 0)} | "
    base_prompt += f"Files: {stats.get('total_files', 0)} | "
    base_prompt += f"Active Users: {stats.get('active_users_today', 0)} | "
    base_prompt += f"Online Users: {stats.get('online_users', 0)}\n\n"
    
    base_prompt += f"USER QUERY: {user_message}\n\n"
    base_prompt += "ASSISTANT RESPONSE (using full database context with write capabilities):"
    
    return base_prompt

from datetime import date
from sqlalchemy import or_, func
def get_active_users_today():
    today = date.today()
    active_today = User.query.filter(
        or_(
            func.date(User.created_at) == today,
            User.id.in_(
                db.session.query(Message.user_id).filter(func.date(Message.created_at) == today)
                .union(db.session.query(Announcement.user_id).filter(func.date(Announcement.created_at) == today))
                .union(db.session.query(Assignment.user_id).filter(func.date(Assignment.created_at) == today))
            )
        )
    ).distinct().count()
    return active_today

    
def get_complete_database_context(user_message, current_user):
    """Get COMPLETE database access without limits - Exclusive AI Permission"""
    message_lower = user_message.lower()
    context = {'context_type': 'full_database', 'data': {}}
    
    try:
        # =========================================
        # COMPLETE USER DATA ACCESS
        # =========================================
        context['data']['all_users'] = [
            {
                'id': user.id,
                'username': user.username,
                'mobile': user.mobile,
                'is_admin': user.is_admin,
                'created_at': user.created_at.isoformat() if user.created_at else 'Unknown',
                'announcements_count': len(user.announcements),
                'assignments_count': len(user.assignments),
                'messages_count': len(user.messages),
                'files_count': len(user.uploaded_files)
            } for user in User.query.all()
        ]
        
        # =========================================
        # COMPLETE ANNOUNCEMENTS ACCESS
        # =========================================
        context['data']['all_announcements'] = [
            {
                'id': a.id,
                'title': a.title,
                'content': a.content,
                'created_at': a.created_at.isoformat() if a.created_at else 'Unknown',
                'author_id': a.user_id,
                'author_name': a.author.username if a.author else 'Unknown',
                'has_file': a.has_file(),
                'file_name': a.file_name,
                'file_type': a.file_type
            } for a in Announcement.query.all()
        ]
        
        # =========================================
        # COMPLETE ASSIGNMENTS ACCESS
        # =========================================
        context['data']['all_assignments'] = [
            {
                'id': a.id,
                'title': a.title,
                'description': a.description,
                'due_date': a.due_date.isoformat() if a.due_date else 'No due date',
                'created_at': a.created_at.isoformat() if a.created_at else 'Unknown',
                'topic_id': a.topic_id,
                'topic_name': a.topic.name if a.topic else 'No topic',
                'creator_id': a.user_id,
                'creator_name': a.creator.username if a.creator else 'Unknown',
                'has_file': bool(a.file_data),
                'file_name': a.file_name,
                'file_type': a.file_type
            } for a in Assignment.query.all()
        ]
        
        # =========================================
        # COMPLETE TOPICS ACCESS
        # =========================================
        context['data']['all_topics'] = [
            {
                'id': t.id,
                'name': t.name,
                'description': t.description,
                'created_at': t.created_at.isoformat() if t.created_at else 'Unknown',
                'assignments_count': len(t.assignments),
                'timetable_slots_count': len(t.timetable_slots),
                'materials_count': len(t.topic_materials)
            } for t in Topic.query.all()
        ]
        
        # =========================================
        # COMPLETE MESSAGES ACCESS
        # =========================================
        context['data']['recent_messages'] = [
            {
                'id': m.id,
                'content': m.content,
                'user_id': m.user_id,
                'username': m.user.username if m.user else 'Unknown',
                'room': m.room,
                'is_admin_message': m.is_admin_message,
                'is_deleted': m.is_deleted,
                'created_at': m.created_at.isoformat() if m.created_at else 'Unknown',
                'parent_id': m.parent_id,
                'replies_count': len(m.replies)
            } for m in Message.query.order_by(Message.created_at.desc()).limit(200).all()
        ]
        
        # =========================================
        # COMPLETE FILES ACCESS
        # =========================================
        context['data']['all_files'] = [
            {
                'id': f.id,
                'name': f.name,
                'filename': f.filename,
                'file_type': f.file_type,
                'file_size': f.file_size,
                'description': f.description,
                'category': f.category,
                'uploaded_at': f.uploaded_at.isoformat() if f.uploaded_at else 'Unknown',
                'uploaded_by': f.uploader.username if f.uploader else 'Unknown',
                'uploader_id': f.uploaded_by
            } for f in File.query.all()
        ]
        
        # =========================================
        # COMPLETE TIMETABLE ACCESS
        # =========================================
        context['data']['complete_timetable'] = [
            {
                'id': t.id,
                'day_of_week': t.day_of_week,
                'start_time': t.start_time.strftime('%H:%M') if t.start_time else 'Unknown',
                'end_time': t.end_time.strftime('%H:%M') if t.end_time else 'Unknown',
                'subject': t.subject,
                'room': t.room,
                'teacher': t.teacher,
                'topic_id': t.topic_id,
                'topic_name': t.topic.name if t.topic else 'No topic',
                'created_at': t.created_at.isoformat() if t.created_at else 'Unknown'
            } for t in Timetable.query.all()
        ]
        
        # =========================================
        # COMPLETE TOPIC MATERIALS ACCESS
        # =========================================
        context['data']['all_topic_materials'] = [
            {
                'id': tm.id,
                'topic_id': tm.topic_id,
                'topic_name': tm.topic.name if tm.topic else 'Unknown',
                'file_id': tm.file_id,
                'file_name': tm.file.name if tm.file else 'Unknown',
                'display_name': tm.display_name,
                'description': tm.description,
                'order_index': tm.order_index,
                'created_at': tm.created_at.isoformat() if tm.created_at else 'Unknown'
            } for tm in TopicMaterial.query.all()
        ]
        
        # =========================================
        # COMPLETE AI CONVERSATIONS ACCESS
        # =========================================
        context['data']['ai_conversations'] = [
            {
                'id': conv.id,
                'user_id': conv.user_id,
                'username': conv.user.username if conv.user else 'Unknown',
                'user_message': conv.user_message,
                'ai_response': conv.ai_response,
                'context_used': conv.context_used,
                'created_at': conv.created_at.isoformat() if conv.created_at else 'Unknown'
            } for conv in AIConversation.query.order_by(AIConversation.created_at.desc()).limit(100).all()
        ]
        
        # =========================================
        # REAL-TIME STATISTICS
        # =========================================
        context['data']['platform_statistics'] = {
            'total_users': User.query.count(),
            'total_admins': User.query.filter_by(is_admin=True).count(),
            'total_announcements': Announcement.query.count(),
            'total_assignments': Assignment.query.count(),
            'total_messages': Message.query.count(),
            'total_files': File.query.count(),
            'total_topics': Topic.query.count(),
            'total_timetable_slots': Timetable.query.count(),
            'total_ai_conversations': AIConversation.query.count(),
            'online_users': len([uid for uid in online_users.keys() if online_users.get(uid)]),
            'active_users_today': get_active_users_today(),
            'current_user': {
                'id': current_user.id,
                'username': current_user.username,
                'is_admin': current_user.is_admin,
                'created_at': current_user.created_at.isoformat() if current_user.created_at else 'Unknown'
            }
        }
        
        # =========================================
        # DATABASE HEALTH STATUS
        # =========================================
        try:
            db.session.execute(text("SELECT 1"))  # Test connection
            context['data']['database_status'] = {
                'status': 'healthy',
                'tables_accessed': len(context['data']),
                'total_records': sum(len(records) for records in context['data'].values() if isinstance(records, list))
            }
        except Exception as e:
            context['data']['database_status'] = {
                'status': 'error',
                'error': str(e)
            }
    
    except Exception as e:
        print(f"Complete Database Context Error: {e}")
        context['data']['error'] = f"Database access error: {str(e)}"
    
    return context

import requests

def call_gemini_api(prompt):
    """Call the Gemini API with the prepared prompt and switch API keys if one fails"""
    API_KEYS = [
        'AIzaSyA3o8aKHTnVzuW9-qg10KjNy7Lcgn19N2I',  # Primary key
        'AIzaSyCq8-xrPTC40k8E_i3vXZ_-PR6RiPsuOno'
    ]
    MODEL = "gemini-2.0-flash-lite"

    for API_KEY in API_KEYS:
        API_URL = f"https://generativelanguage.googleapis.com/v1beta/models/{MODEL}:generateContent?key={API_KEY}"
        
        try:
            response = requests.post(
                API_URL,
                headers={"Content-Type": "application/json"},
                json={
                    "contents": [{
                        "parts": [{"text": prompt}]
                    }],
                    "generationConfig": {
                        "temperature": 0.7,
                        "topK": 40,
                        "topP": 0.95,
                        "maxOutputTokens": 2048,
                    },
                    "safetySettings": [
                        {
                            "category": "HARM_CATEGORY_HARASSMENT",
                            "threshold": "BLOCK_MEDIUM_AND_ABOVE"
                        },
                        {
                            "category": "HARM_CATEGORY_HATE_SPEECH", 
                            "threshold": "BLOCK_MEDIUM_AND_ABOVE"
                        }
                    ]
                },
                timeout=45
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'candidates' in data and len(data['candidates']) > 0:
                    return data['candidates'][0]['content']['parts'][0]['text']
                else:
                    return "I received an unexpected response format from the AI service."
            else:
                print(f"API key failed ({API_KEY[:10]}...): HTTP {response.status_code}")
                continue  # try next key
        
        except requests.exceptions.Timeout:
            return "The request timed out. This might be due to the complexity of your query or high server load. Please try again with a more specific question."
        
        except Exception as e:
            print(f"Gemini API Error with {API_KEY[:10]}...: {e}")
            continue  # try next key

    return "I'm currently unavailable due to a technical issue. Please check your connection and try again later."

def save_ai_conversation(user_id, user_message, ai_response, context_used='full_database'):
    """Save AI conversation to database"""
    try:
        conversation = AIConversation(
            user_id=user_id,
            user_message=user_message,
            ai_response=ai_response,
            context_used=context_used
        )
        db.session.add(conversation)
        db.session.commit()
        
        print(f"AI Conversation saved - User {user_id}: {user_message[:100]}...")
        
    except Exception as e:
        db.session.rollback()
        print(f"Error saving AI conversation: {e}")

@app.route('/api/ai-chat/history')
@login_required
def get_ai_chat_history():
    """Get AI chat history for the current user"""
    try:
        conversations = AIConversation.query.filter_by(
            user_id=current_user.id
        ).order_by(AIConversation.created_at.desc()).limit(50).all()
        
        conversations_data = []
        for conv in conversations:
            conversations_data.append({
                'id': conv.id,
                'user_message': conv.user_message,
                'ai_response': conv.ai_response,
                'context_used': conv.context_used,
                'created_at': conv.created_at.isoformat() if conv.created_at else None
            })
        
        return jsonify({'conversations': conversations_data})
        
    except Exception as e:
        print(f"Error fetching AI chat history: {e}")
        return jsonify({'conversations': []})

@app.route('/api/ai-chat/clear-history', methods=['DELETE'])
@login_required
def clear_ai_chat_history():
    """Clear AI chat history for the current user"""
    try:
        # Delete all AI conversations for the current user
        deleted_count = AIConversation.query.filter_by(user_id=current_user.id).delete()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Cleared {deleted_count} conversations from history'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'success': False,
            'error': 'Failed to clear chat history'
        }), 500

@app.route('/api/ai-chat/statistics')
@login_required
@admin_required
def get_ai_chat_statistics():
    """Get AI chat usage statistics (Admin only)"""
    try:
        total_conversations = AIConversation.query.count()
        total_users = db.session.query(db.func.count(db.distinct(AIConversation.user_id))).scalar()
        
        recent_conversations = AIConversation.query.filter(
            AIConversation.created_at >= datetime.now() - timedelta(days=7)
        ).count()
        
        context_usage = db.session.query(
            AIConversation.context_used,
            db.func.count(AIConversation.id)
        ).group_by(AIConversation.context_used).all()
        
        top_users = db.session.query(
            User.username,
            db.func.count(AIConversation.id)
        ).join(AIConversation).group_by(User.id, User.username).order_by(
            db.func.count(AIConversation.id).desc()
        ).limit(10).all()
        
        return jsonify({
            'total_conversations': total_conversations,
            'total_users': total_users,
            'recent_conversations_7_days': recent_conversations,
            'context_usage': {context: count for context, count in context_usage},
            'top_users': [{'username': username, 'conversation_count': count} for username, count in top_users]
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500



# =========================================
# DATABASE QUERY SERVICE CLASS
# =========================================

class DatabaseQueryService:
    """
    A comprehensive service class for querying the entire database
    with support for filtering, pagination, and relationship loading
    """
    
    def __init__(self, db_session):
        self.db = db_session
        self.models = {
            'User': User,
            'Announcement': Announcement,
            'Assignment': Assignment,
            'Topic': Topic,
            'Timetable': Timetable,
            'Message': Message,
            'File': File,
            'TopicMaterial': TopicMaterial,
            'AIConversation': AIConversation,
            'Visit': Visit,
            'UserActivity': UserActivity,
            'AdminCode': AdminCode,
            'MessageRead': MessageRead
        }
    
    def get_all_models(self):
        """Return all available models"""
        return list(self.models.keys())
    
    def query_model(self, model_name, filters=None, relations=None, 
                   paginate=False, page=1, per_page=50, order_by=None):
        """
        Generic model query with filtering and relationships
        
        Args:
            model_name (str): Name of the model to query
            filters (dict): Dictionary of filter conditions
            relations (list): List of relationships to load
            paginate (bool): Whether to paginate results
            page (int): Page number for pagination
            per_page (int): Items per page
            order_by (str): Field to order by (prefix with - for DESC)
        
        Returns:
            dict: Query results with metadata
        """
        if model_name not in self.models:
            return {'error': f'Model {model_name} not found'}
        
        Model = self.models[model_name]
        query = Model.query
        
        # Load relationships
        if relations:
            for relation in relations:
                if hasattr(Model, relation):
                    query = query.options(db.joinedload(getattr(Model, relation)))
        
        # Apply filters
        if filters:
            for field, value in filters.items():
                if hasattr(Model, field):
                    if isinstance(value, dict):
                        # Handle operators like gt, lt, like, etc.
                        for op, op_value in value.items():
                            if op == 'eq':
                                query = query.filter(getattr(Model, field) == op_value)
                            elif op == 'ne':
                                query = query.filter(getattr(Model, field) != op_value)
                            elif op == 'gt':
                                query = query.filter(getattr(Model, field) > op_value)
                            elif op == 'lt':
                                query = query.filter(getattr(Model, field) < op_value)
                            elif op == 'like':
                                query = query.filter(getattr(Model, field).ilike(f'%{op_value}%'))
                            elif op == 'in':
                                query = query.filter(getattr(Model, field).in_(op_value))
                    else:
                        # Simple equality filter
                        query = query.filter(getattr(Model, field) == value)
        
        # Apply ordering
        if order_by:
            if order_by.startswith('-'):
                field = order_by[1:]
                if hasattr(Model, field):
                    query = query.order_by(getattr(Model, field).desc())
            else:
                if hasattr(Model, order_by):
                    query = query.order_by(getattr(Model, order_by).asc())
        
        # Execute query with or without pagination
        if paginate:
            pagination = query.paginate(
                page=page, 
                per_page=per_page, 
                error_out=False
            )
            
            return {
                'data': [self.serialize_item(item) for item in pagination.items],
                'pagination': {
                    'page': page,
                    'per_page': per_page,
                    'total': pagination.total,
                    'pages': pagination.pages,
                    'has_next': pagination.has_next,
                    'has_prev': pagination.has_prev
                },
                'model': model_name,
                'filters_applied': filters,
                'count': len(pagination.items)
            }
        else:
            items = query.all()
            return {
                'data': [self.serialize_item(item) for item in items],
                'model': model_name,
                'filters_applied': filters,
                'count': len(items)
            }
    
    def serialize_item(self, item):
        """Serialize a database item to JSON-serializable format"""
        if not item:
            return None
        
        result = {}
        
        for column in item.__table__.columns:
            value = getattr(item, column.name)
            
            # Handle different data types
            if isinstance(value, datetime):
                result[column.name] = value.isoformat()
            elif isinstance(value, date):
                result[column.name] = value.isoformat()
            elif isinstance(value, time):
                result[column.name] = value.strftime('%H:%M:%S')
            elif isinstance(value, bytes):
                result[column.name] = f'<binary data {len(value)} bytes>'
            else:
                result[column.name] = value
        
        return result
    
    def get_model_stats(self, model_name):
        """Get statistics for a specific model"""
        if model_name not in self.models:
            return {'error': f'Model {model_name} not found'}
        
        Model = self.models[model_name]
        
        total_count = Model.query.count()
        
        # Get date-based stats if model has created_at
        if hasattr(Model, 'created_at'):
            today = datetime.now().date()
            today_count = Model.query.filter(
                db.func.date(Model.created_at) == today
            ).count()
            
            week_ago = today - timedelta(days=7)
            week_count = Model.query.filter(
                Model.created_at >= week_ago
            ).count()
        else:
            today_count = 0
            week_count = 0
        
        return {
            'model': model_name,
            'total_count': total_count,
            'today_count': today_count,
            'last_7_days_count': week_count
        }
    
    def execute_raw_sql(self, sql, params=None):
        """Execute raw SQL query safely"""
        try:
            if params is None:
                params = {}
            
            result = self.db.session.execute(db.text(sql), params)
            
            # Handle different types of queries
            if sql.strip().lower().startswith('select'):
                columns = result.keys()
                rows = result.fetchall()
                return {
                    'columns': list(columns),
                    'data': [dict(zip(columns, row)) for row in rows],
                    'row_count': len(rows)
                }
            else:
                self.db.session.commit()
                return {
                    'affected_rows': result.rowcount,
                    'message': 'Query executed successfully'
                }
                
        except Exception as e:
            self.db.session.rollback()
            return {'error': str(e)}
    
    def get_related_data(self, model_name, item_id, relation_name):
        """Get related data for a specific item"""
        if model_name not in self.models:
            return {'error': f'Model {model_name} not found'}
        
        Model = self.models[model_name]
        item = Model.query.get(item_id)
        
        if not item:
            return {'error': f'{model_name} with id {item_id} not found'}
        
        if not hasattr(item, relation_name):
            return {'error': f'Relation {relation_name} not found in {model_name}'}
        
        related_items = getattr(item, relation_name)
        
        # Handle both list and single relationships
        if isinstance(related_items, list):
            return {
                'model': model_name,
                'item_id': item_id,
                'relation': relation_name,
                'data': [self.serialize_item(rel_item) for rel_item in related_items],
                'count': len(related_items)
            }
        else:
            return {
                'model': model_name,
                'item_id': item_id,
                'relation': relation_name,
                'data': self.serialize_item(related_items)
            }
    
    def search_across_models(self, search_term, model_names=None, field_names=None):
        """Search across multiple models and fields"""
        if model_names is None:
            model_names = self.get_all_models()
        
        results = {}
        
        for model_name in model_names:
            if model_name not in self.models:
                continue
                
            Model = self.models[model_name]
            query = Model.query
            
            # Build search conditions
            conditions = []
            for column in Model.__table__.columns:
                if field_names and column.name not in field_names:
                    continue
                
                # Only search string-based columns
                if isinstance(column.type, (db.String, db.Text)):
                    conditions.append(column.ilike(f'%{search_term}%'))
            
            if conditions:
                query = query.filter(db.or_(*conditions))
                items = query.limit(50).all()
                
                if items:
                    results[model_name] = {
                        'count': len(items),
                        'data': [self.serialize_item(item) for item in items]
                    }
        
        return {
            'search_term': search_term,
            'total_results': sum(len(result['data']) for result in results.values()),
            'results_by_model': results
        }

# Create a global instance
db_query_service = DatabaseQueryService(db)

# =========================================
# DATABASE QUERY ROUTES
# =========================================

@app.route('/api/database/query', methods=['POST'])
@login_required
@admin_required
def database_query():
    """
    Execute database queries with filtering and pagination
    Expected JSON payload:
    {
        "model": "User",
        "filters": {"is_admin": true, "username": {"like": "john"}},
        "relations": ["announcements", "assignments"],
        "paginate": true,
        "page": 1,
        "per_page": 20,
        "order_by": "-created_at"
    }
    """
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No JSON data provided'}), 400
        
        model_name = data.get('model')
        if not model_name:
            return jsonify({'error': 'Model name is required'}), 400
        
        result = db_query_service.query_model(
            model_name=model_name,
            filters=data.get('filters'),
            relations=data.get('relations'),
            paginate=data.get('paginate', False),
            page=data.get('page', 1),
            per_page=data.get('per_page', 50),
            order_by=data.get('order_by')
        )
        
        if 'error' in result:
            return jsonify(result), 400
        
        return jsonify(result)
    
    except Exception as e:
        return jsonify({'error': f'Query execution failed: {str(e)}'}), 500

@app.route('/api/database/models', methods=['GET'])
@login_required
@admin_required
def get_available_models():
    """Get all available database models"""
    models = db_query_service.get_all_models()
    return jsonify({'models': models})

@app.route('/api/database/models/<model_name>/stats', methods=['GET'])
@login_required
@admin_required
def get_model_stats(model_name):
    """Get statistics for a specific model"""
    stats = db_query_service.get_model_stats(model_name)
    
    if 'error' in stats:
        return jsonify(stats), 404
    
    return jsonify(stats)

@app.route('/api/database/raw', methods=['POST'])
@login_required
@admin_required
def execute_raw_query():
    """
    Execute raw SQL query (admin only - use with caution)
    Expected JSON payload:
    {
        "sql": "SELECT * FROM users WHERE is_admin = :admin",
        "params": {"admin": true}
    }
    """
    try:
        data = request.get_json()
        
        if not data or 'sql' not in data:
            return jsonify({'error': 'SQL query is required'}), 400
        
        # Basic safety check - prevent destructive operations in GET requests
        sql = data['sql'].strip().lower()
        destructive_operations = ['drop', 'delete', 'truncate', 'alter', 'create']
        
        if any(op in sql for op in destructive_operations):
            return jsonify({
                'error': 'Destructive operations are not allowed via this endpoint'
            }), 403
        
        result = db_query_service.execute_raw_sql(
            data['sql'],
            data.get('params')
        )
        
        if 'error' in result:
            return jsonify(result), 400
        
        return jsonify(result)
    
    except Exception as e:
        return jsonify({'error': f'Raw query failed: {str(e)}'}), 500

@app.route('/api/database/search', methods=['POST'])
@login_required
@admin_required
def search_database():
    """
    Search across multiple models and fields
    Expected JSON payload:
    {
        "search_term": "john",
        "models": ["User", "Announcement"],
        "fields": ["username", "title", "content"]
    }
    """
    try:
        data = request.get_json()
        
        if not data or 'search_term' not in data:
            return jsonify({'error': 'Search term is required'}), 400
        
        result = db_query_service.search_across_models(
            search_term=data['search_term'],
            model_names=data.get('models'),
            field_names=data.get('fields')
        )
        
        return jsonify(result)
    
    except Exception as e:
        return jsonify({'error': f'Search failed: {str(e)}'}), 500

@app.route('/api/database/<model_name>/<int:item_id>/<relation_name>', methods=['GET'])
@login_required
@admin_required
def get_related_items(model_name, item_id, relation_name):
    """Get related items for a specific database record"""
    result = db_query_service.get_related_data(model_name, item_id, relation_name)
    
    if 'error' in result:
        return jsonify(result), 404
    
    return jsonify(result)

# Add this to your app.py after all the model definitions and before the routes

# Import the blueprint (save the above code as gemini_bp.py)
from gemini_bp import gemini_bp

# Register the blueprint
app.register_blueprint(gemini_bp)

# Also add this route to your existing app.py to link to the Gemini chat
@app.route('/lyx-ai')
@login_required
def ai_assistant():
    """Redirect to the Gemini chat interface"""
    return redirect(url_for('gemini.gemini_chat'))
#=======================================================================================================
@app.route('/')
def home():
    return render_template('index.html', year=_year())
#--------------------------------------------------------------------
@app.route('/terms')
def terms():
    return render_template('terms.html', year=_year())
#--------------------------------------------------------------------
@app.route('/logout')
@login_required
def logout():
    logout_user()
    flash('Logout Successfully!', 'sucess')
    return redirect(url_for('home'))
#--------------------------------------------------------------------
@app.route('/main-page')
@limiter.limit("10 per minute")
@login_required
def main_page():
    return render_template('main_page.html', year=_year())
#-----------------------------------------------------------------
@app.route('/navigation-guide')
def nav_guide():
    return render_template('navigation.html')
#--------------------------------------------------------------------
@app.route('/test')
def test_template():
    return render_template('test.html')
#--------------------------------------------------------------------
@app.route('/admin')
@login_required
@admin_required
def admin_page():
    return render_template('admin.html', year=_year())
#--------------------------------------------------------------------
@app.route('/admin/users')
@login_required
@admin_required
def admin_users():
    return render_template('admin_users.html')
#-----------------------------------------------------------------
@app.route('/profile')
@login_required
def profile():
    """Render the profile edit page"""
    return render_template('edit_profile.html')
#--------------------------------------------------------------------
@app.route('/files')
@limiter.limit("10 per minute")
@login_required
def files():
    """Render the file management page"""
    return render_template('files.html')
#--------------------------------------------------------------------
@app.route('/material/<int:topic_id>')
@login_required
def topic_materials(topic_id):
    """Render the topic materials page"""
    topic = Topic.query.get_or_404(topic_id)
    return render_template('material.html', topic_id=topic_id)
#--------------------------------------------------------------------
@app.route('/favicon.ico')
def favicon():
    return send_from_directory(app.config['UPLOAD_FOLDER'], 'favicon.ico')
#--------------------------------------------------------------------
@app.route('/uploads/<filename>')
def uploaded_file(filename):
    if '..' in filename or filename.startswith('/'):
        abort(400, "Invalid filename")
    
    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    if os.path.exists(file_path):
        return send_from_directory(app.config['UPLOAD_FOLDER'], filename)
    else:
        abort(404, "File not found")
#--------------------------------------------------------------------
@app.route('/manifest.json')
def manifest():
    return send_from_directory(os.path.dirname(os.path.abspath(__file__)), 'manifest.json', mimetype='application/manifest+json')
#--------------------------------------------------------------------
@app.route("/offline.html")
def offline_html():
    return render_template("offline.html")
#-------------------------------------------------------------------
@app.route('/service-worker.js')
def sw():
    return send_from_directory('static', 'service-worker.js', mimetype='application/javascript')
#-------------------------------------------------------------------
@app.route('/is_authenticated')
def is_authenticated():
    return jsonify({'authenticated': current_user.is_authenticated})
#-------------------------------------------------------------------
#              SPECIFIED ROUTES

def format_message_time(created_at):
    now = datetime.now()
    delta = now - created_at

    if delta < timedelta(days=1):
        # Less than a day: show time
        return created_at.strftime('%H:%M')
    elif delta < timedelta(days=7):
        # Less than a week: show weekday
        return created_at.strftime('%a')  # Mon, Tue, Wed, ...
    elif delta < timedelta(days=30):
        # Less than a month: show weeks ago
        weeks = delta.days // 7
        return f"{weeks} week{'s' if weeks > 1 else ''} ago"
    elif delta < timedelta(days=365):
        # Less than a year: show months ago
        months = delta.days // 30
        return f"{months} month{'s' if months > 1 else ''} ago"
    else:
        # A year or more: show years ago
        years = delta.days // 365
        return f"{years} year{'s' if years > 1 else ''} ago"

app.jinja_env.filters['message_time'] = format_message_time
# =========================================
#              MESSAGES ROUTES
# =========================================

@app.route('/messages')
@limiter.limit("10 per minute")
@login_required
def messages():
    """Render the messages page with initial data"""
    try:
        room = request.args.get('room', 'general')
        
        # (last 50 messages)
        messages = Message.query.filter_by(
            room=room, 
            is_deleted=False
        ).order_by(Message.created_at.desc()).limit(50).all()
        
        messages.reverse()
        
        unread_count = get_unread_count(current_user.id)
        
        if hasattr(current_user, 'current_room'):
            current_user.current_room = room
            db.session.commit()
        
        return render_template(
            'messages.html',
            messages=messages,
            current_user=current_user,
            unread_count=unread_count,
            room=room
        )
        
    except Exception as e:
        print(f"Error loading messages page: {e}")
        # Fallback: returns page without messages
        return render_template(
            'messages.html',
            messages=[],
            current_user=current_user,
            unread_count=0,
            room='general'
        )

@app.route('/messages/<room_name>')
@login_required
def messages_room(room_name):
    """Render messages page for a specific room"""
    try:
        valid_rooms = ['general', 'help', 'announcements']
        if room_name not in valid_rooms:
            room_name = 'general'
        
        messages = Message.query.filter_by(
            room=room_name, 
            is_deleted=False
        ).order_by(Message.created_at.desc()).limit(50).all()
        
        messages.reverse()
        
        # Get unread count - Still fixing
        unread_count = get_unread_count(current_user.id)
        
        if hasattr(current_user, 'current_room'):
            current_user.current_room = room_name
            db.session.commit()
        
        return render_template(
            'messages.html',
            messages=messages,
            current_user=current_user,
            unread_count=unread_count,
            room=room_name
        )
        
    except Exception as e:
        print(f"Error loading messages room {room_name}: {e}")
        return render_template(
            'messages.html',
            messages=[],
            current_user=current_user,
            unread_count=0,
            room=room_name
        )
    

from sqlalchemy import select

def get_unread_count(user_id):
    """
    Count unread messages for a given user safely.
    Uses SQLAlchemy 2.x compatible select() for subqueries.
    """
    try:
        # Select message IDs that user has already read
        read_message_ids = select(MessageRead.message_id).filter_by(user_id=user_id)

        # Count messages not in that list
        unread_count = (
            db.session.query(Message)
            .filter(
                Message.id.not_in(read_message_ids),
                Message.is_deleted == False,
                Message.user_id != user_id
            )
            .count()
        )

        return unread_count

    except Exception as e:
        print(f"⚠️ Error getting unread count for user {user_id}: {e}")
        return 0

#=================================================
#                  FILE API
#==========================================
@app.route('/api/files')
@login_required
def get_files():
    """Get all files with pagination and filtering"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    category = request.args.get('category', '')
    search = request.args.get('search', '')
    
    query = File.query
    
    if category:
        query = query.filter(File.category == category)
    
    if search:
        query = query.filter(
            db.or_(
                File.name.ilike(f'%{search}%'),
                File.description.ilike(f'%{search}%'),
                File.filename.ilike(f'%{search}%')
            )
        )
    
    # pagination
    files_pagination = query.order_by(File.uploaded_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    files_data = []
    for file in files_pagination.items:
        files_data.append({
            'id': file.id,
            'name': file.name,
            'filename': file.filename,
            'file_type': file.file_type,
            'file_size': file.file_size,
            'description': file.description,
            'category': file.category,
            'uploaded_at': file.uploaded_at.isoformat(),
            'updated_at': file.updated_at.isoformat(),
            'uploaded_by': file.uploader.username if file.uploader else 'Unknown',
            'can_delete': current_user.is_admin or current_user.id == file.uploaded_by
        })
    
    return jsonify({
        'files': files_data,
        'total': files_pagination.total,
        'pages': files_pagination.pages,
        'current_page': page,
        'has_next': files_pagination.has_next,
        'has_prev': files_pagination.has_prev
    })

def shorten_filename(filename, length=30):
    name, ext = os.path.splitext(filename)
    return f"{name[:length]}...{ext}" if len(name) > length else filename

@app.route('/api/files/upload', methods=['POST'])
@login_required
def upload_file():
    """Upload a new file"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    name = request.form.get('name', file.filename)[:100]
    filename = shorten_filename(file.filename)
    description = request.form.get('description', '')[:12000]
    category = request.form.get('category', 'general')
    
    # Validate file size (10MB limit) - Memory 1GB only
    file_data = file.read()
    if len(file_data) > 10 * 1024 * 1024:
        return jsonify({'error': 'File size exceeds 10MB limit'}), 400
    
    # Check if filename already exists - No duplicates Unique Key Constrains
    existing_file = File.query.filter_by(filename=file.filename).first()
    if existing_file:
        return jsonify({'error': 'A file with this name already exists'}), 400
    
    try:
        new_file = File(
            name=name,
            filename=filename,
            file_type=file.content_type,
            file_size=len(file_data),
            file_data=file_data,
            description=description,
            category=category,
            uploaded_by=current_user.id
        )
        
        db.session.add(new_file)
        db.session.commit()
        
        return jsonify({
            'message': 'File uploaded successfully',
            'file': {
                'id': new_file.id,
                'name': new_file.name,
                'filename': new_file.filename,
                'file_type': new_file.file_type,
                'file_size': new_file.file_size
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': 'Failed to upload file'}), 500

@app.route('/api/files/<int:id>/download')
@login_required
def download_file(id):
    """Download a file"""
    file = File.query.get_or_404(id)
    
    return send_file(
        BytesIO(file.file_data),
        download_name=file.filename,
        as_attachment=True,
        mimetype=file.file_type
    )

@app.route('/api/files/<int:id>', methods=['DELETE'])
@login_required
@admin_required
def delete_file(id):
    """Delete a file"""
    file = File.query.get_or_404(id)

    try:
        db.session.delete(file)
        db.session.commit()
        
        return jsonify({'message': 'File deleted successfully'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': 'Failed to delete file'}), 500

@app.route('/api/files/categories')
@login_required
def get_file_categories():
    """Get all file categories"""
    categories = db.session.query(File.category).distinct().all()
    category_list = [cat[0] for cat in categories if cat[0]]
    
    return jsonify({'categories': category_list})

#================================================
#            UPDATE USER API ROUTES
#==========================================
@app.route('/api/user/profile', methods=['GET'])
@login_required
def get_user_profile():
    """Get current user's profile data"""
    user_data = {
        'id': current_user.id,
        'username': current_user.username,
        'mobile': current_user.mobile,
        'created_at': current_user.created_at.isoformat(),
        'is_admin': current_user.is_admin,
        'announcements_count': len(current_user.announcements),
        'assignments_count': len(current_user.assignments)
    }
    return jsonify(user_data)

@app.route('/api/user/profile', methods=['PUT'])
@login_required
def update_user_profile():
    """Update current user's profile"""
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'No data provided'}), 400
    
    username = data.get('username', '').strip()
    mobile = data.get('mobile', '').strip()
    
    if not username or len(username) > 200:
        return jsonify({'error': 'Username must be between 1 and 200 characters'}), 400
    
    # Validate mobile format - For those enetering 08 ....
    mobile_regex = r'^(07|01)[0-9]{8}$'
    if not re.match(mobile_regex, mobile):
        return jsonify({'error': 'Mobile number must be 10 digits starting with 07 or 01'}), 400
    
    existing_user = User.query.filter(
        User.mobile == mobile, 
        User.id != current_user.id
    ).first()
    
    if existing_user:
        return jsonify({'error': 'Mobile number is already registered'}), 400
    
    try:
        current_user.username = username
        current_user.mobile = mobile
        db.session.commit()
        
        return jsonify({
            'message': 'Profile updated successfully',
            'user': {
                'id': current_user.id,
                'username': current_user.username,
                'mobile': current_user.mobile
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': 'Failed to update profile'}), 500


# ===============================================================
#          MESSAGES API ROUTES & SOCKET HANDLERS
# ===========================================================

online_users = {}

@app.route('/api/online-users')
@login_required
def get_online_users():
    """Get currently online users"""
    
    users = []
    for user_id, user_data in online_users.items():
        if user_data and 'user_id' in user_data:
            users.append({
                'user_id': user_data['user_id'],
                'username': user_data['username'],
                'is_admin': user_data.get('is_admin', False),
                'last_seen': user_data.get('last_seen'),
                'room': user_data.get('current_room', 'general')
            })
    
    return jsonify(users)

@app.route('/api/messages')
@login_required
def get_messages():
    """Get messages for a room with optional filtering"""
    room = request.args.get('room', 'general')
    since_id = request.args.get('since_id', 0, type=int)
    limit = request.args.get('limit', 100, type=int)
    
    try:
        query = Message.query.filter_by(room=room, is_deleted=False)
        
        if since_id > 0:
            query = query.filter(Message.id > since_id)
        
        messages = query.order_by(Message.created_at.asc()).limit(limit).all()
        
        read_message_ids = set()
        if current_user.is_authenticated:
            read_records = MessageRead.query.filter_by(user_id=current_user.id).all()
            read_message_ids = {record.message_id for record in read_records}
        
        # Format response
        messages_data = []
        for message in messages:
            message_data = {
                'id': message.id,
                'content': message.content,
                'user_id': message.user_id,
                'username': message.user.username,
                'is_admin': message.user.is_admin,
                'is_admin_message': message.is_admin_message,
                'created_at': message.created_at.isoformat(),
                'room': message.room,
                'is_read': message.id in read_message_ids,
                'parent_id': message.parent_id,
                'has_replies': len(message.replies) > 0 if message.replies else False
            }
            
            if message.parent_id:
                parent_message = Message.query.get(message.parent_id)
                if parent_message and not parent_message.is_deleted:
                    message_data['parent'] = {
                        'id': parent_message.id,
                        'content': parent_message.content,
                        'username': parent_message.user.username,
                        'user_id': parent_message.user_id
                    }
            
            messages_data.append(message_data)
        
        return jsonify({
            'success': True,
            'messages': messages_data,
            'room': room,
            'total': len(messages_data)
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/messages/read', methods=['POST'])
@login_required
def mark_messages_read():
    """Mark messages as read for current user"""
    try:
        data = request.get_json()
        message_ids = data.get('message_ids', [])
        
        if not message_ids:
            return jsonify({'success': False, 'error': 'No message IDs provided'}), 400
        
        for message_id in message_ids:
            existing_read = MessageRead.query.filter_by(
                message_id=message_id, 
                user_id=current_user.id
            ).first()
            
            if not existing_read:
                message_read = MessageRead(
                    message_id=message_id,
                    user_id=current_user.id
                )
                db.session.add(message_read)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Marked {len(message_ids)} messages as read',
            'read_count': len(message_ids)
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/messages/send', methods=['POST'])
@login_required
def send_message():
    """Send a message via HTTP API (fallback)"""
    try:
        data = request.get_json()
        content = data.get('content', '').strip()
        room = data.get('room', 'general')
        parent_id = data.get('parent_id')  # To track replies
        
        if not content:
            return jsonify({'success': False, 'error': 'Message content is required'}), 400
        
        if parent_id:
            parent_message = Message.query.get(parent_id)
            if not parent_message or parent_message.is_deleted:
                return jsonify({'success': False, 'error': 'Parent message not found'}), 404
        
        message = Message(
            content=content,
            user_id=current_user.id,
            room=room,
            is_admin_message=current_user.is_admin,
            parent_id=parent_id
        )
        
        db.session.add(message)
        db.session.commit()
        
        message_data = {
            'id': message.id,
            'content': message.content,
            'user_id': message.user_id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'is_admin_message': current_user.is_admin,
            'created_at': message.created_at.isoformat(),
            'room': room,
            'parent_id': parent_id,
            'is_read': False
        }
        
        if parent_id:
            parent_message = Message.query.get(parent_id)
            if parent_message and not parent_message.is_deleted:
                message_data['parent'] = {
                    'id': parent_message.id,
                    'content': parent_message.content,
                    'username': parent_message.user.username
                }
        
        socketio.emit('new_message', message_data, room=room)
        
        return jsonify({
            'success': True,
            'message': message_data
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/messages/<int:message_id>/reply', methods=['POST'])
@login_required
def reply_to_message(message_id):
    """Reply to a specific message"""
    try:
        data = request.get_json()
        content = data.get('content', '').strip()
        
        if not content:
            return jsonify({'success': False, 'error': 'Reply content is required'}), 400
        
        parent_message = Message.query.get(message_id)
        if not parent_message or parent_message.is_deleted:
            return jsonify({'success': False, 'error': 'Message not found'}), 404
        
        reply = Message(
            content=content,
            user_id=current_user.id,
            room=parent_message.room,
            is_admin_message=current_user.is_admin,
            parent_id=message_id
        )
        
        db.session.add(reply)
        db.session.commit()
        
        reply_data = {
            'id': reply.id,
            'content': reply.content,
            'user_id': reply.user_id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'is_admin_message': current_user.is_admin,
            'created_at': reply.created_at.isoformat(),
            'room': parent_message.room,
            'parent_id': message_id,
            'is_read': False,
            'parent': {
                'id': parent_message.id,
                'content': parent_message.content,
                'username': parent_message.user.username
            }
        }
        
        socketio.emit('new_message', reply_data, room=parent_message.room)
        
        return jsonify({
            'success': True,
            'message': reply_data
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/messages/<int:message_id>', methods=['DELETE'])
@login_required
def delete_message(message_id):
    """Delete a message (soft delete)"""
    try:
        message = Message.query.get(message_id)
        
        if not message:
            return jsonify({'success': False, 'error': 'Message not found'}), 404
        
        if message.user_id != current_user.id and not current_user.is_admin:
            return jsonify({'success': False, 'error': 'Permission denied'}), 403
        
        # Soft delete
        message.is_deleted = True
        message.deleted_at = nairobi_time()
        message.content = "[This message was deleted]"
        
        db.session.commit()
        
        socketio.emit('message_deleted', {
            'message_id': message_id,
            'room': message.room,
            'deleted_by': current_user.id,
            'is_admin_action': current_user.is_admin
        }, room=message.room)
        
        return jsonify({
            'success': True,
            'message': 'Message deleted successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/messages/<int:message_id>/replies')
@login_required
def get_message_replies(message_id):
    """Get replies for a specific message"""
    try:
        message = Message.query.get(message_id)
        
        if not message or message.is_deleted:
            return jsonify({'success': False, 'error': 'Message not found'}), 404
        
        replies = Message.query.filter_by(
            parent_id=message_id, 
            is_deleted=False
        ).order_by(Message.created_at.asc()).all()
        
        read_message_ids = set()
        if current_user.is_authenticated:
            read_records = MessageRead.query.filter_by(user_id=current_user.id).all()
            read_message_ids = {record.message_id for record in read_records}
        
        replies_data = []
        for reply in replies:
            reply_data = {
                'id': reply.id,
                'content': reply.content,
                'user_id': reply.user_id,
                'username': reply.user.username,
                'is_admin': reply.user.is_admin,
                'is_admin_message': reply.is_admin_message,
                'created_at': reply.created_at.isoformat(),
                'room': reply.room,
                'parent_id': reply.parent_id,
                'is_read': reply.id in read_message_ids
            }
            replies_data.append(reply_data)
        
        return jsonify({
            'success': True,
            'replies': replies_data,
            'parent_message': {
                'id': message.id,
                'content': message.content,
                'username': message.user.username
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


#=========Handle Private Room
#=======================
import hashlib
import secrets

# Simple in-memory storage for private rooms (replace with database in production)
private_rooms = {}

@app.route('/api/private-rooms/create', methods=['POST'])
@login_required
def create_private_room():
    try:
        data = request.get_json()
        room_name = data.get('room_name', '').strip()
        room_key = data.get('room_key', '').strip()
        
        # Validation
        if not room_name or len(room_name) < 3 or len(room_name) > 5:
            return jsonify({'success': False, 'error': 'Room name must be 3-5 characters'})
        
        if not room_key or len(room_key) != 6:
            return jsonify({'success': False, 'error': 'Room key must be exactly 6 characters'})
        
        # Check if room already exists
        if room_name in private_rooms:
            return jsonify({'success': False, 'error': 'Room name already exists'})
        
        # Create room with hashed key
        hashed_key = hashlib.sha256(room_key.encode()).hexdigest()
        private_rooms[room_name] = {
            'hashed_key': hashed_key,
            'creator_id': current_user.id,
            'members': [current_user.id],
            'created_at': datetime.utcnow().isoformat()
        }
        
        return jsonify({'success': True, 'room_name': room_name})
        
    except Exception as e:
        return jsonify({'success': False, 'error': 'Server error: ' + str(e)})

@app.route('/api/private-rooms/join', methods=['POST'])
@login_required
def join_private_room():
    try:
        data = request.get_json()
        room_name = data.get('room_name', '').strip()
        room_key = data.get('room_key', '').strip()
        
        # Validation
        if not room_name:
            return jsonify({'success': False, 'error': 'Room name is required'})
        
        if not room_key:
            return jsonify({'success': False, 'error': 'Room key is required'})
        
        # Check if room exists
        if room_name not in private_rooms:
            return jsonify({'success': False, 'error': 'Room does not exist'})
        
        # Verify room key
        hashed_key = hashlib.sha256(room_key.encode()).hexdigest()
        room = private_rooms[room_name]
        
        if room['hashed_key'] != hashed_key:
            return jsonify({'success': False, 'error': 'Invalid room key'})
        
        # Add user to room members if not already there
        if current_user.id not in room['members']:
            room['members'].append(current_user.id)
        
        return jsonify({'success': True, 'room_name': room_name})
        
    except Exception as e:
        return jsonify({'success': False, 'error': 'Server error: ' + str(e)})

# =========================================
#          EXTRA FUNCTIONS CLEAN UP - MEMORY CONSTRAIN
# ===========================================================

def cleanup_disconnected_users():
    """Remove users who haven't been seen for more than 30 seconds"""
    current_time = datetime.utcnow()
    disconnected_users = []
    
    for user_id, user_data in online_users.items():
        if user_data and 'last_seen' in user_data:
            last_seen = user_data['last_seen']
            if isinstance(last_seen, str):
                try:
                    last_seen = datetime.fromisoformat(last_seen.replace('Z', '+00:00')) + timedelta(hours=3)
                except:
                    continue
            
            if current_time - last_seen > timedelta(seconds=30):
                disconnected_users.append(user_id)
    
    for user_id in disconnected_users:
        user_data = online_users.pop(user_id, None)
        if user_data:
            room = user_data.get('current_room', 'general')
            emit('user_left', {
                'user_id': user_data['user_id'],
                'username': user_data['username'],
                'message': f'{user_data["username"]} left the chat'
            }, room=room, include_self=False)

def update_user_presence(user_id, username, is_admin=False, room='general'):
    """Update user's online status and room"""
    online_users[user_id] = {
        'user_id': user_id,
        'username': username,
        'is_admin': is_admin,
        'current_room': room,
        'last_seen': datetime.utcnow().isoformat()
    }
    
    room_users = []
    for uid, user_data in online_users.items():
        if user_data and user_data.get('current_room') == room:
            room_users.append({
                'user_id': user_data['user_id'],
                'username': user_data['username'],
                'is_admin': user_data.get('is_admin', False)
            })
    
    emit('online_users_update', {'users': room_users}, room=room)

def broadcast_online_users():
    """Broadcast updated online users list to all rooms"""

    room_users = {}
    for user_id, user_data in online_users.items():
        if user_data and 'user_id' in user_data:
            room = user_data.get('current_room', 'general')
            if room not in room_users:
                room_users[room] = []
            
            room_users[room].append({
                'user_id': user_data['user_id'],
                'username': user_data['username'],
                'is_admin': user_data.get('is_admin', False)
            })
    
    for room, users in room_users.items():
        emit('online_users_update', {'users': users}, room=room)

# =========================================
#             SOCKET.IO HANDLERS
# =========================================

@socketio.on('connect')
def handle_connect():
    """Handle user connection"""
    if current_user.is_authenticated:
        update_user_presence(
            user_id=current_user.id,
            username=current_user.username,
            is_admin=current_user.is_admin,
            room='general'
        )
        
        join_room('general')
        
        emit('user_joined', {
            'user_id': current_user.id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'message': f'{current_user.username} joined the chat'
        }, room='general', include_self=False)
        
        emit('user_info', {
            'user_id': current_user.id,
            'username': current_user.username,
            'is_admin': current_user.is_admin
        })
        
        print(f"User {current_user.username} connected. Online users: {len(online_users)}")

@socketio.on('disconnect')
def handle_disconnect():
    """Handle user disconnection safely"""
    try:
        user = getattr(current_user, "username", None)
        user_id = getattr(current_user, "id", None)

        if not user_id:
            print("Anonymous socket disconnected.")
            return

        user_data = online_users.pop(user_id, None)
        if not user_data:
            print(f"User {user or 'Unknown'} had no active session.")
            return

        room = user_data.get('current_room', 'general')

        # Emit safely — may fail if socket already gone
        try:
            emit(
                'user_left',
                {
                    'user_id': user_id,
                    'username': user,
                    'message': f'{user} left the chat',
                },
                room=room,
                include_self=False
            )
        except OSError as e:
            if e.errno != 9:  # ignore 'Bad file descriptor'
                raise
            print(f"Ignored closed socket emit for {user}")

        broadcast_online_users()

        print(f"User {user} disconnected. Online users: {len(online_users)}")

    except Exception as e:
        print(f"⚠️ Disconnect error: {e}")

# I'm not that good at this part
@socketio.on('join_room')
def handle_join_room(data):
    """Handle joining a room"""
    if current_user.is_authenticated:
        room = data.get('room', 'general')
        previous_room = online_users.get(current_user.id, {}).get('current_room', 'general')
        
        if previous_room != room:
            leave_room(previous_room)
            emit('user_left', {
                'user_id': current_user.id,
                'username': current_user.username,
                'message': f'{current_user.username} left {previous_room}'
            }, room=previous_room, include_self=False)
        
        join_room(room)
        
        update_user_presence(
            user_id=current_user.id,
            username=current_user.username,
            is_admin=current_user.is_admin,
            room=room
        )
        
        emit('user_joined', {
            'user_id': current_user.id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'message': f'{current_user.username} joined {room}'
        }, room=room, include_self=False)
        
        messages = Message.query.filter_by(room=room, is_deleted=False).order_by(Message.created_at.asc()).limit(50).all()
        
        read_message_ids = set()
        if current_user.is_authenticated:
            read_records = MessageRead.query.filter_by(user_id=current_user.id).all()
            read_message_ids = {record.message_id for record in read_records}
        
        for message in messages:
            message_data = {
                'id': message.id,
                'content': message.content,
                'user_id': message.user_id,
                'username': message.user.username,
                'is_admin': message.user.is_admin,
                'is_admin_message': message.is_admin_message,
                'created_at': message.created_at.isoformat(),
                'room': room,
                'is_read': message.id in read_message_ids,
                'parent_id': message.parent_id
            }
            
            if message.parent_id:
                parent_message = Message.query.get(message.parent_id)
                if parent_message and not parent_message.is_deleted:
                    message_data['parent'] = {
                        'id': parent_message.id,
                        'content': parent_message.content,
                        'username': parent_message.user.username
                    }
            
            emit('new_message', message_data)

@socketio.on('leave_room')
def handle_leave_room(data):
    """Handle leaving a room"""
    if current_user.is_authenticated:
        room = data.get('room', 'general')
        leave_room(room)
    
        update_user_presence(
            user_id=current_user.id,
            username=current_user.username,
            is_admin=current_user.is_admin,
            room='general'
        )
        
        emit('user_left', {
            'user_id': current_user.id,
            'username': current_user.username,
            'message': f'{current_user.username} left {room}'
        }, room=room, include_self=False)
        
        join_room('general')
        
        emit('room_left', {
            'room': room,
            'user_id': current_user.id,
            'username': current_user.username
        })

@socketio.on('send_message')
def handle_send_message(data):
    if not current_user.is_authenticated:
        return {'success': False, 'error': 'Not authenticated'}
    
    content = data.get('content', '').strip()
    room = data.get('room', 'general')
    parent_id = data.get('parent_id')
    
    if not content:
        return {'success': False, 'error': 'Empty message'}
    
    if parent_id:
        parent_message = Message.query.get(parent_id)
        if not parent_message or parent_message.is_deleted:
            return {'success': False, 'error': 'Parent message not found'}
    
    update_user_presence(
        user_id=current_user.id,
        username=current_user.username,
        is_admin=current_user.is_admin,
        room=room
    )
    
    message = Message(
        content=content,
        user_id=current_user.id,
        room=room,
        is_admin_message=current_user.is_admin,
        parent_id=parent_id
    )
    
    try:
        db.session.add(message)
        db.session.commit()
        
        message_data = {
            'id': message.id,
            'content': message.content,
            'user_id': message.user_id,
            'username': current_user.username,
            'is_admin': current_user.is_admin,
            'is_admin_message': current_user.is_admin,
            'created_at': message.created_at.isoformat(),
            'room': room,
            'parent_id': parent_id,
            'is_read': False
        }
        
        if parent_id:
            parent_message = Message.query.get(parent_id)
            if parent_message and not parent_message.is_deleted:
                message_data['parent'] = {
                    'id': parent_message.id,
                    'content': parent_message.content,
                    'username': parent_message.user.username
                }
        
        emit('new_message', message_data, room=room)
        
        return {'success': True, 'message': message_data}
        
    except Exception as e:
        db.session.rollback()
        return {'success': False, 'error': str(e)}

@socketio.on('delete_message')
def handle_delete_message(data):
    """Handle message deletion via WebSocket"""
    if not current_user.is_authenticated:
        return {'success': False, 'error': 'Not authenticated'}
    
    message_id = data.get('message_id')
    
    if not message_id:
        return {'success': False, 'error': 'Message ID required'}
    
    try:
        message = Message.query.get(message_id)
        
        if not message:
            return {'success': False, 'error': 'Message not found'}
        
        if message.user_id != current_user.id and not current_user.is_admin:
            return {'success': False, 'error': 'Permission denied'}
        
        # Soft delete message --> but still deletes from db .
        message.is_deleted = True
        message.deleted_at = nairobi_time()
        message.content = "[This message was deleted]"
        
        db.session.commit()
        
        emit('message_deleted', {
            'message_id': message_id,
            'room': message.room,
            'deleted_by': current_user.id,
            'is_admin_action': current_user.is_admin
        }, room=message.room)
        
        return {'success': True, 'message': 'Message deleted successfully'}
        
    except Exception as e:
        db.session.rollback()
        return {'success': False, 'error': str(e)}

@socketio.on('typing')
def handle_typing(data):
    """Handle typing indicator"""
    if current_user.is_authenticated:
        room = data.get('room', 'general')
        emit('user_typing', {
            'user_id': current_user.id,
            'username': current_user.username,
            'room': room
        }, room=room, include_self=False)

@socketio.on('ping')
def handle_ping(data):
    """Handle ping for connection health check"""
    if current_user.is_authenticated:
        user_room = online_users.get(current_user.id, {}).get('current_room', 'general')
        
        # Update user presence
        update_user_presence(
            user_id=current_user.id,
            username=current_user.username,
            is_admin=current_user.is_admin,
            room=user_room
        )
        
        emit('pong', {'timestamp': data.get('timestamp')})

@socketio.on('get_messages')
def handle_get_messages(data):
    if current_user.is_authenticated:
        room = data.get('room', 'general')
        since_id = data.get('since_id', 0)
        limit = data.get('limit', 100)
        
        try:
            query = Message.query.filter_by(room=room, is_deleted=False)
            if since_id > 0:
                query = query.filter(Message.id > since_id)
            
            messages = query.order_by(Message.created_at.asc()).limit(limit).all()
            
            read_message_ids = set()
            if current_user.is_authenticated:
                read_records = MessageRead.query.filter_by(user_id=current_user.id).all()
                read_message_ids = {record.message_id for record in read_records}
            
            messages_data = []
            for message in messages:
                message_data = {
                    'id': message.id,
                    'content': message.content,
                    'user_id': message.user_id,
                    'username': message.user.username,
                    'is_admin': message.user.is_admin,
                    'is_admin_message': message.is_admin_message,
                    'created_at': message.created_at.isoformat(),
                    'room': room,
                    'is_read': message.id in read_message_ids,
                    'parent_id': message.parent_id
                }
                
                if message.parent_id:
                    parent_message = Message.query.get(message.parent_id)
                    if parent_message and not parent_message.is_deleted:
                        message_data['parent'] = {
                            'id': parent_message.id,
                            'content': parent_message.content,
                            'username': parent_message.user.username
                        }
                
                messages_data.append(message_data)
            
            emit('messages_batch', {
                'room': room,
                'messages': messages_data,
                'since_id': since_id,
                'total': len(messages_data)
            })
            
        except Exception as e:
            emit('messages_error', {
                'error': str(e),
                'room': room
            })

@socketio.on('mark_read')
def handle_mark_read(data):
    if not current_user.is_authenticated:
        return
    
    message_ids = data.get('message_ids', [])
    
    if not message_ids:
        return
    
    try:
        for message_id in message_ids:
            existing_read = MessageRead.query.filter_by(
                message_id=message_id, 
                user_id=current_user.id
            ).first()
            
            if not existing_read:
                message_read = MessageRead(
                    message_id=message_id,
                    user_id=current_user.id
                )
                db.session.add(message_read)
        
        db.session.commit()
        
        emit('messages_read', {
            'message_ids': message_ids,
            'user_id': current_user.id,
            'username': current_user.username
        }, broadcast=True)
        
    except Exception as e:
        db.session.rollback()
        print(f"Error marking messages as read: {e}")

# ================================================
        # PERIODIC TASKS FOR KEEP ALIVE THE WEBS
# ==================================================
import requests

TARGET_URLS = [
    "https://lyxspace.onrender.com/files",
    "https://lyxnexus.onrender.com/"
]

def ping_urls():
    for url in TARGET_URLS:
        try:
            response = requests.get(url, timeout=5)
            print(f"Pinged {url} | Status: {response.status_code}")
        except requests.RequestException as e:
            print(f"Failed to ping {url}: {e}")

scheduler = BackgroundScheduler()
scheduler.add_job(func=ping_urls, trigger="interval", minutes=3)
scheduler.start()

atexit.register(lambda: scheduler.shutdown())

TARGET_URL = 'https://lyxspace.onrender.com/files'
@app.route("/ping-lyx")
def manual_ping():
    try:
        response = requests.get(TARGET_URL, timeout=5)
        return {
            "url": TARGET_URL,
            "status_code": response.status_code,
            "success": response.ok
        }
    except requests.RequestException as e:
        return {
            "url": TARGET_URL,
            "error": str(e),
            "success": False
        }

#===========================================
@app.route('/api/users')
@login_required
@admin_required
def get_users():
    # Get query parameters for filtering, search, and pagination
    search = request.args.get('search', '')
    role = request.args.get('role', '')
    activity_level = request.args.get('activity_level', '')
    status = request.args.get('status', '')
    date_filter = request.args.get('date_filter', '')
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    
    # Base query
    query = User.query
    
    # Apply search filter
    if search:
        search_term = f"%{search}%"
        query = query.filter(
            db.or_(
                User.username.ilike(search_term),
                User.mobile.ilike(search_term),
                User.id.cast(db.String).ilike(search_term)
            )
        )
    
    # Apply role filter
    if role == 'admin':
        query = query.filter(User.is_admin == True)
    elif role == 'user':
        query = query.filter(User.is_admin == False)
    
    # Apply date filter
    if date_filter:
        today = datetime.now().date()
        if date_filter == 'today':
            query = query.filter(db.func.date(User.created_at) == today)
        elif date_filter == 'week':
            week_ago = today - timedelta(days=7)
            query = query.filter(User.created_at >= week_ago)
        elif date_filter == 'month':
            month_ago = today - timedelta(days=30)
            query = query.filter(User.created_at >= month_ago)
    
    # Get total count BEFORE applying status/activity filters (for pagination)
    total_users_after_filters = query.count()
    
    # Apply pagination
    users = (
        query.order_by(User.username.asc())
        .offset((page - 1) * per_page)
        .limit(per_page)
        .all()
    )
    
    # Get online users for status filtering
    online_user_ids = [user_data.get('user_id') for user_data in online_users.values() 
                      if user_data and 'user_id' in user_data]
    
    # user data with activity metrics
    users_data = []
    for user in users:
        # Calculate total activity
        total_activity = len(user.announcements) + len(user.assignments)
        
        # Determine activity level
        user_activity_level = 'low'
        if total_activity > 10:
            user_activity_level = 'high'
        elif total_activity > 3:
            user_activity_level = 'medium'
        
        # Check if user is online
        is_online = user.id in online_user_ids
        
        users_data.append({
            'id': user.id,
            'username': user.username,
            'mobile': user.mobile,
            'created_at': user.created_at.isoformat() if user.created_at else None,
            'is_admin': user.is_admin,
            'announcements_count': len(user.announcements),
            'assignments_count': len(user.assignments),
            'total_activity': total_activity,
            'activity_level': user_activity_level,
            'is_online': is_online,
            'last_activity': get_user_last_activity(user)
        })
    
    # needed filters can't be easily done in SQL
    filtered_users_data = users_data
    
    if status:
        if status == 'online':
            filtered_users_data = [user for user in filtered_users_data if user['is_online']]
        elif status == 'offline':
            filtered_users_data = [user for user in filtered_users_data if not user['is_online']]
    
    if activity_level:
        filtered_users_data = [user for user in filtered_users_data if user['activity_level'] == activity_level]
    
    # Get additional statistics for charts and quick stats
    stats = get_user_statistics()
    
    # Calculate final counts
    final_count = len(filtered_users_data)
    
    return jsonify({
        'users': filtered_users_data,
        'pagination': {
            'page': page,
            'per_page': per_page,
            'total': User.query.count(),  # Total users in database
            'total_filtered': total_users_after_filters,  # Total after SQL filters
            'final_count': final_count,  # Total after all filters
            'pages': (total_users_after_filters + per_page - 1) // per_page
        },
        'stats': stats
    })

def get_user_last_activity(user):
    """Get the last activity timestamp for a user"""
    last_announcement = db.session.query(db.func.max(Announcement.created_at)).filter(
        Announcement.user_id == user.id
    ).scalar()
    
    last_assignment = db.session.query(db.func.max(Assignment.created_at)).filter(
        Assignment.user_id == user.id
    ).scalar()
    
    last_message = db.session.query(db.func.max(Message.created_at)).filter(
        Message.user_id == user.id
    ).scalar()
    
    # Return the most recent activity
    activities = [last_announcement, last_assignment, last_message]
    valid_activities = [a for a in activities if a is not None]
    
    return max(valid_activities).isoformat() if valid_activities else user.created_at.isoformat()

def get_user_statistics():
    """Get comprehensive user statistics for charts and quick stats"""
    total_users = User.query.count()
    admin_users = User.query.filter_by(is_admin=True).count()
    regular_users = total_users - admin_users
    
    # Today's registrations
    today = datetime.now().date()
    today_users = User.query.filter(db.func.date(User.created_at) == today).count()
    
    # Active today (users with any activity today)
    active_today = User.query.filter(
        db.or_(
            db.func.date(User.created_at) == today,
            User.id.in_(
                db.session.query(Message.user_id).filter(
                    db.func.date(Message.created_at) == today
                ).union(
                    db.session.query(Announcement.user_id).filter(
                        db.func.date(Announcement.created_at) == today
                    )
                ).union(
                    db.session.query(Assignment.user_id).filter(
                        db.func.date(Assignment.created_at) == today
                    )
                )
            )
        )
    ).distinct().count()
    
    # Online users count
    online_count = len([uid for uid in online_users.keys() 
                       if online_users[uid] and 'user_id' in online_users[uid]])
    
    # Average activity per user
    total_announcements = db.session.query(db.func.count(Announcement.id)).scalar() or 0
    total_assignments = db.session.query(db.func.count(Assignment.id)).scalar() or 0
    total_activity = total_announcements + total_assignments
    
    avg_activity = round(total_activity / total_users, 1) if total_users > 0 else 0
    
    # Registration trend data (last 30 days)
    registration_trend = []
    for i in range(30):
        date = today - timedelta(days=29 - i)
        count = User.query.filter(db.func.date(User.created_at) == date).count()
        registration_trend.append({
            'date': date.isoformat(),
            'count': count
        })
    
    # Activity distribution
    activity_distribution = {
        'high': User.query.join(Announcement).join(Assignment).group_by(User.id).having(
            (db.func.count(Announcement.id) + db.func.count(Assignment.id)) > 10
        ).count(),
        'medium': User.query.join(Announcement).join(Assignment).group_by(User.id).having(
            (db.func.count(Announcement.id) + db.func.count(Assignment.id)) > 3,
            (db.func.count(Announcement.id) + db.func.count(Assignment.id)) <= 10
        ).count(),
        'low': User.query.outerjoin(Announcement).outerjoin(Assignment).group_by(User.id).having(
            (db.func.count(Announcement.id) + db.func.count(Assignment.id)) <= 3
        ).count()
    }
    
    return {
        'total_users': total_users,
        'admin_users': admin_users,
        'regular_users': regular_users,
        'today_users': today_users,
        'active_today': active_today,
        'online_users': online_count,
        'total_activity': total_activity,
        'avg_activity': avg_activity,
        'registration_trend': registration_trend,
        'activity_distribution': activity_distribution,
        'role_distribution': {
            'admins': admin_users,
            'regular_users': regular_users
        }
    }

@app.route('/api/users/<int:user_id>/delete', methods=['POST'])
@login_required
@admin_required
def delete_user(user_id):
    user = User.query.get_or_404(user_id)

    if user.id == current_user.id:
        return jsonify({'error': 'Cannot delete your own account'}), 400

    try:
        # =====================================================
        # 1️. Delete MessageReads for messages SENT BY this user
        # =====================================================
        user_message_ids = [m.id for m in Message.query.filter_by(user_id=user.id).all()]
        if user_message_ids:
            db.session.query(MessageRead).filter(
                MessageRead.message_id.in_(user_message_ids)
            ).delete(synchronize_session=False)

        # =========================================================
        # 2️. Delete MessageReads BY this user
        # =========================================================
        db.session.query(MessageRead).filter_by(user_id=user.id).delete(synchronize_session=False)

        # ==========================================
        # 3️. Delete Replies to user's messages FIRST
        # ==========================================
        if user_message_ids:
            db.session.query(Message).filter(
                Message.parent_id.in_(user_message_ids)
            ).delete(synchronize_session=False)

        # ==================================
        # 4️. Delete messages CREATED BY user
        # ==================================
        db.session.query(Message).filter_by(user_id=user.id).delete(synchronize_session=False)

        # =====================================
        # 5️. Delete assignments & announcements
        # =====================================
        db.session.query(Announcement).filter_by(user_id=user.id).delete(synchronize_session=False)
        db.session.query(Assignment).filter_by(user_id=user.id).delete(synchronize_session=False)

        # ================================
        # 6️. Delete files uploaded by user
        # ================================
        user_file_ids = [f.id for f in File.query.filter_by(uploaded_by=user.id).all()]
        if user_file_ids:
            db.session.query(TopicMaterial).filter(
                TopicMaterial.file_id.in_(user_file_ids)
            ).delete(synchronize_session=False)
            db.session.query(File).filter(File.id.in_(user_file_ids)).delete(synchronize_session=False)

        # ==================================
        # 7️. Delete orphaned TopicMaterials
        # ==================================
        db.session.query(TopicMaterial).filter_by(file_id=None).delete(synchronize_session=False)

        # ==========================================
        # 8️. Delete new user-linked models (tracking)
        # ==========================================
        db.session.query(AIConversation).filter_by(user_id=user.id).delete(synchronize_session=False)
        db.session.query(Visit).filter_by(user_id=user.id).delete(synchronize_session=False)
        db.session.query(UserActivity).filter_by(user_id=user.id).delete(synchronize_session=False)
        db.session.query(AdminCode).filter_by(user_id=user.id).delete(synchronize_session=False)

        # =============================
        # 9️. Finally delete the user 😤
        # =============================
        db.session.delete(user)
        db.session.commit()

        return jsonify({'message': f'User {user.username or user.id} deleted successfully with all related data.'})

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': f'Failed to delete user: {str(e)}'}), 500

@app.route('/api/users/<int:user_id>/toggle-admin', methods=['PUT'])
@login_required
@admin_required
def toggle_admin(user_id):
    
    user = User.query.get_or_404(user_id)
    
    if user.id == current_user.id:
        return jsonify({'error': 'Cannot modify your own admin status'}), 400
    
    user.is_admin = not user.is_admin
    db.session.commit()
    
    return jsonify({
        'message': 'Admin status updated successfully',
        'is_admin': user.is_admin
    })

# =========================================
# ANNOUNCEMENT API ROUTES
# =========================================
import io

@app.route('/api/announcements')
def get_announcements():
    try:
        announcements = Announcement.query.order_by(Announcement.created_at.desc()).all()
        result = [{
            'id': a.id,
            'title': a.title,
            'content': a.content,
            'created_at': a.created_at.isoformat(),
            'author': {'id': a.author.id, 'username': a.author.username} if a.author else None,
            'has_file': a.has_file(),
            'file_name': a.file_name,
            'file_type': a.file_type,
            'file_url': a.get_file_url()
        } for a in announcements]
        return jsonify(result)
    except Exception as e:
        app.logger.exception("Failed to fetch announcements")
        return jsonify({'error': 'Failed to fetch announcements'}), 500

from werkzeug.utils import secure_filename

@app.route('/api/announcements/create', methods=['POST'])
@login_required
@admin_required
def create_announcement():
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    title = request.form.get('title')
    content = request.form.get('content')

    file = request.files.get('file')
    file_name = secure_filename(file.filename) if file else None
    file_type = file.mimetype if file else None
    file_data = file.read() if file else None

    announcement = Announcement(
        title=title,
        content=content,
        user_id=current_user.id,
        file_name=file_name,
        file_type=file_type,
        file_data=file_data
    )
    db.session.add(announcement)
    db.session.commit()

    send_notification(
        current_user.id,
        'New Announcement Created',
        f'You created: {announcement.title}'
    )
    
    # Broadcast to all users
    socketio.emit('push_notification', {
        'title': 'New Announcement',
        'message': f'New announcement: {announcement.title}',
        'type': 'announcement',
        'announcement_id': announcement.id,
        'timestamp': datetime.utcnow().isoformat()
    })
    return jsonify({'message': 'Announcement created successfully', 'id': announcement.id}), 201

@app.route('/api/announcements/<int:id>', methods=['PUT'])
@login_required
@admin_required
def update_announcement(id):
    """Update an announcement with optional file"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    announcement = Announcement.query.get_or_404(id)
    title = request.form.get('title', announcement.title)
    content = request.form.get('content', announcement.content)
    file = request.files.get('file')

    announcement.title = title
    announcement.content = content

    if file:
        announcement.file_name = secure_filename(file.filename)
        announcement.file_type = file.mimetype
        announcement.file_data = file.read()

    db.session.commit()

    send_notification(
        current_user.id,
        'Editted Announcement Created',
        f'You created: {announcement.title}'
    )
    
    # Broadcast to all users
    socketio.emit('push_notification', {
        'title': 'Announcement Editted',
        'message': f'announcement eddited: {announcement.title}',
        'type': 'announcement',
        'announcement_id': announcement.id,
        'timestamp': datetime.utcnow().isoformat()
    })    
    return jsonify({'message': 'Announcement updated successfully'})


@app.route('/api/announcements/<int:id>', methods=['DELETE'])
@login_required
@admin_required
def delete_announcement(id):
    """Delete an announcement (Admin only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    announcement = Announcement.query.get_or_404(id)
    send_notification(
        current_user.id,
        'Deleted Announcement',
        f'You Deleted: {announcement.title}'
    )

    socketio.emit('push_notification', {
        'title': 'Announcement Deleted', 
        'message': f'Announcement was deleted by {current_user.username}',
        'type': 'announcement',
        'announcement_id': announcement.id,
        'timestamp': datetime.utcnow().isoformat()
    })    
    db.session.delete(announcement)
    db.session.commit()
    
    return jsonify({'message': 'Announcement deleted successfully'})

@app.route('/announcement-file/<int:id>/<filename>')
def serve_announcement_file(id, filename):
    announcement = Announcement.query.get_or_404(id)
    if not announcement.has_file() or announcement.file_name != filename:
        return jsonify({'error': 'File not found'}), 404

    return send_file(
        io.BytesIO(announcement.file_data),
        download_name=announcement.file_name,
        mimetype=announcement.file_type
    )
# =========================================
# ASSIGNMENT API ROUTES
# =========================================

@app.route('/api/assignments')
def get_assignments():
    """Get all assignments"""
    assignments = Assignment.query.order_by(Assignment.due_date.asc()).all()
    result = []
    for assignment in assignments:
        result.append({
            'id': assignment.id,
            'title': assignment.title,
            'description': assignment.description,
            'due_date': assignment.due_date.isoformat() if assignment.due_date else None,
            'created_at': assignment.created_at.isoformat(),
            'file_name': assignment.file_name,
            'file_type': assignment.file_type,
            'topic': {
                'id': assignment.topic.id,
                'name': assignment.topic.name
            } if assignment.topic else None,
            'creator': {
                'id': assignment.creator.id,
                'username': assignment.creator.username
            } if assignment.creator else None
        })
    return jsonify(result)

@app.route('/api/assignments', methods=['POST'])
@login_required
@admin_required
def create_assignment():
    """Create a new assignment (Admin/Teacher only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    data = request.get_json()
    assignment = Assignment(
        title=data.get('title'),
        description=data.get('description'),
        due_date=datetime.fromisoformat(data.get('due_date')) if data.get('due_date') else None,
        topic_id=data.get('topic_id'),
        user_id=current_user.id
    )
    db.session.add(assignment)
    db.session.commit()
    send_notification(
        current_user.id,
        'Assignment Given',
        f'You Deleted: {assignment.title}'
    )

    socketio.emit('push_notification', {
        'title': 'Assignment handed out', 
        'message': f' Assignment on: {assignment.title}',
        'type': 'assignment',
        'assignment_id': assignment.id,
        'timestamp': datetime.utcnow().isoformat()
    })    
    
    return jsonify({'message': 'Assignment created successfully', 'id': assignment.id}), 201

@app.route('/api/assignments/<int:id>', methods=['PUT'])
@login_required
@admin_required
def update_assignment(id):
    """Update an assignment (Admin/Teacher only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    assignment = Assignment.query.get_or_404(id)
    data = request.get_json()
    
    assignment.title = data.get('title', assignment.title)
    assignment.description = data.get('description', assignment.description)
    if data.get('due_date'):
        assignment.due_date = datetime.fromisoformat(data.get('due_date'))
    assignment.topic_id = data.get('topic_id', assignment.topic_id)
    
    db.session.commit()
    send_notification(
        current_user.id,
        'Assignment Updated',
        f'You updated: {assignment.title}'
    )

    socketio.emit('push_notification', {
        'title': 'Assignment Updated', 
        'message': f' Assignment {assignment.title} updated',
        'type': 'assignment',
        'assignment_id': assignment.id,
        'timestamp': datetime.utcnow().isoformat()
    })    
    
    return jsonify({'message': 'Assignment updated successfully'})

@app.route('/api/assignments/<int:id>', methods=['DELETE'])
@login_required
@admin_required
def delete_assignment(id):
    """Delete an assignment (Admin/Teacher only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    assignment = Assignment.query.get_or_404(id)
    send_notification(
        current_user.id,
        'Assignment Deletd',
        f'You Deleted: {assignment.title}'
    )

    socketio.emit('push_notification', {
        'title': 'Assignment Deleted', 
        'message': f' Assignment {assignment.title} deleted',
        'type': 'assignment',
        'assignment_id': assignment.id,
        'timestamp': datetime.utcnow().isoformat()
    })        
    db.session.delete(assignment)
    db.session.commit()
    
    return jsonify({'message': 'Assignment deleted successfully'})

@app.route('/api/assignments/<int:id>/upload', methods=['POST'])
@login_required
@admin_required
def upload_assignment_file(id):
    """Upload file for assignment (Admin/Teacher only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    assignment = Assignment.query.get_or_404(id)
    
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    assignment.file_data = file.read()
    assignment.file_name = file.filename
    assignment.file_type = file.content_type
    
    db.session.commit()
    
    return jsonify({'message': 'File uploaded successfully'})

@app.route('/api/assignments/<int:id>/download')
def download_assignment_file(id):
    """Download assignment file"""
    assignment = Assignment.query.get_or_404(id)
    
    if not assignment.file_data:
        return jsonify({'error': 'No file available'}), 404
    
    return send_file(
        BytesIO(assignment.file_data),
        download_name=assignment.file_name,
        as_attachment=True,
        mimetype=assignment.file_type
    )
@app.route('/assignment/<int:id>')
@login_required
def assignment_page(id):
    """Serve the assignment file view and download page"""
    assignment = Assignment.query.get_or_404(id)
    return render_template('assignment.html', assignment=assignment)

@app.route("/api/preview")
def preview():
    url = request.args.get("url", "")
    if not url:
        return jsonify({"error": "Missing URL"}), 400

    try:
        headers = {"User-Agent": "Mozilla/5.0"}
        response = requests.get(url, headers=headers, timeout=4)
        response.raise_for_status()

        soup = BeautifulSoup(response.text, "html.parser")

        def meta(prop):
            tag = soup.find("meta", property=prop) or soup.find("meta", attrs={"name": prop})
            return tag["content"].strip() if tag and tag.get("content") else None

        title = meta("og:title") or (soup.title.string.strip() if soup.title else None)
        description = meta("og:description") or meta("description")
        image = meta("og:image")

        return jsonify({
            "title": title or "",
            "description": description or "",
            "image": image or ""
        })

    except requests.exceptions.RequestException as e:
        print("OG fetch error:", e)
        return jsonify({"title": "", "description": "", "image": ""})

# =========================================
#              TOPIC API ROUTES
# =========================================

@app.route('/api/topics')
def get_topics():
    """Get all topics"""
    topics = Topic.query.all()
    result = []
    for topic in topics:
        result.append({
            'id': topic.id,
            'name': topic.name,
            'description': topic.description,
            'created_at': topic.created_at.isoformat()
        })
    return jsonify(result)

@app.route('/api/topics', methods=['POST'])
@login_required
@admin_required
def create_topic():
    """Create a new topic (Admin only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    data = request.get_json()
    topic = Topic(
        name=data.get('name'),
        description=data.get('description')
    )
    db.session.add(topic)
    db.session.commit()
    
    return jsonify({'message': 'Topic created successfully', 'id': topic.id}), 201

@app.route('/api/topics/<int:id>', methods=['PUT'])
@login_required
@admin_required
def update_topic(id):
    """Update a topic (Admin only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    topic = Topic.query.get_or_404(id)
    data = request.get_json()
    
    topic.name = data.get('name', topic.name)
    topic.description = data.get('description', topic.description)
    db.session.commit()
    
    return jsonify({'message': 'Topic updated successfully'})

@app.route('/api/topics/<int:id>', methods=['DELETE'])
@login_required
@admin_required
def delete_topic(id):
    """Delete a topic (Admin only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    topic = Topic.query.get_or_404(id)
    db.session.delete(topic)
    db.session.commit()
    
    return jsonify({'message': 'Topic deleted successfully'})

#==========================================
#            TIMETABLE API ROUTES
#==========================================
@app.route('/api/timetable/grouped', methods=['GET'])
def get_timetable():
    """Get timetable grouped by day"""
    print("\n[DEBUG] Fetching grouped timetable...")

    try:
        timetable_slots = Timetable.query.order_by(
            Timetable.day_of_week, 
            Timetable.start_time
        ).all()

        print(f"[DEBUG] Retrieved {len(timetable_slots)} timetable slots from DB")

        days_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        timetable_by_day = {day: [] for day in days_order}

        for slot in timetable_slots:
            print(f"[DEBUG] Processing slot ID {slot.id} ({slot.subject}) on {slot.day_of_week}")
            timetable_by_day[slot.day_of_week].append({
                'id': slot.id,
                'start_time': slot.start_time.strftime('%H:%M'),
                'end_time': slot.end_time.strftime('%H:%M'),
                'time': f"{slot.start_time.strftime('%H:%M')} - {slot.end_time.strftime('%H:%M')}",
                'subject': slot.subject,
                'room': slot.room,
                'teacher': slot.teacher,
                'topic': {
                    'id': slot.topic.id,
                    'name': slot.topic.name
                } if slot.topic else None
            })

        result = [
            {'day': day, 'slots': timetable_by_day[day]}
            for day in days_order if timetable_by_day[day]
        ]

        print(f"[DEBUG] Sending grouped timetable response with {len(result)} days")
        return jsonify(result), 200

    except Exception as e:
        print("[ERROR] Failed to get timetable:", str(e))
        return jsonify({'error': str(e)}), 500

@app.route('/api/timetable', methods=['GET', 'POST'])
def handle_timetable():
    if request.method == 'GET':
        timetable_slots = Timetable.query.order_by(
            Timetable.day_of_week,
            Timetable.start_time
        ).all()
        
        result = []
        for slot in timetable_slots:
            result.append({
                'id': slot.id,
                'day_of_week': slot.day_of_week,
                'start_time': slot.start_time.strftime('%H:%M'),
                'end_time': slot.end_time.strftime('%H:%M'),
                'subject': slot.subject,
                'room': slot.room,
                'teacher': slot.teacher,
                'topic': {
                    'id': slot.topic.id,
                    'name': slot.topic.name
                } if slot.topic else None
            })
        return jsonify(result)

    if request.method == 'POST':
        if not current_user.is_admin:
            return jsonify({'error': 'Unauthorized'}), 403

        data = request.get_json()

        try:
            start_time_str = data.get('start_time')
            end_time_str = data.get('end_time')

            start_time = datetime.strptime(start_time_str, '%H:%M').time()
            end_time = datetime.strptime(end_time_str, '%H:%M').time()

            if start_time >= end_time:
                return jsonify({'error': 'End time must be after start time'}), 400

        except ValueError:
            return jsonify({'error': 'Invalid time format. Use HH:MM format'}), 400
        except Exception as e:
            return jsonify({'error': f'Time parsing error: {str(e)}'}), 400

        timetable_slot = Timetable(
            day_of_week=data.get('day_of_week'),
            start_time=start_time,
            end_time=end_time,
            subject=data.get('subject'),
            room=data.get('room'),
            teacher=data.get('teacher'),
            topic_id=data.get('topic_id')
        )

        db.session.add(timetable_slot)
        db.session.commit()

        return jsonify({
            'message': 'Timetable slot created successfully',
            'id': timetable_slot.id
        }), 201

@app.route('/api/timetable/<int:id>', methods=['PUT'])
@login_required
@admin_required
def update_timetable_slot(id):
    """Update a timetable slot (Admin only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    timetable_slot = Timetable.query.get_or_404(id)
    data = request.get_json()
    
    timetable_slot.day_of_week = data.get('day_of_week', timetable_slot.day_of_week)
    
    if data.get('start_time'):
        timetable_slot.start_time = datetime.strptime(data.get('start_time'), '%H:%M').time()
    if data.get('end_time'):
        timetable_slot.end_time = datetime.strptime(data.get('end_time'), '%H:%M').time()
    
    timetable_slot.subject = data.get('subject', timetable_slot.subject)
    timetable_slot.room = data.get('room', timetable_slot.room)
    timetable_slot.teacher = data.get('teacher', timetable_slot.teacher)
    timetable_slot.topic_id = data.get('topic_id', timetable_slot.topic_id)
    
    db.session.commit()
    
    return jsonify({'message': 'Timetable slot updated successfully'})

@app.route('/api/timetable/<int:id>', methods=['DELETE'])
@login_required
@admin_required
def delete_timetable_slot(id):
    """Delete a timetable slot (Admin only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    timetable_slot = Timetable.query.get_or_404(id)
    db.session.delete(timetable_slot)
    db.session.commit()
    
    return jsonify({'message': 'Timetable slot deleted successfully'})

@app.route('/api/timetable/day/<day>')
def get_timetable_by_day(day):
    """Get timetable for a specific day"""
    timetable_slots = Timetable.query.filter_by(day_of_week=day)\
        .order_by(Timetable.start_time).all()
    
    result = []
    for slot in timetable_slots:
        result.append({
            'id': slot.id,
            'start_time': slot.start_time.strftime('%H:%M'),
            'end_time': slot.end_time.strftime('%H:%M'),
            'time': f"{slot.start_time.strftime('%H:%M')} - {slot.end_time.strftime('%H:%M')}",
            'subject': slot.subject,
            'room': slot.room,
            'teacher': slot.teacher,
            'topic': {
                'id': slot.topic.id,
                'name': slot.topic.name
            } if slot.topic else None
        })
    
    return jsonify(result)

#==========================================
#           REGISTERING ADMIN API
#==========================================

@app.route('/api/register-admin', methods=['POST'])
def register_admin():
    """Register a new admin user via API"""
    data = request.get_json()
    
    mobile = data.get('mobile')
    username = data.get('username')
    master_key = data.get('master_key')
    
    if master_key != MASTER_ADMIN_KEY:
        return jsonify({'error': 'Invalid master authorization key'}), 403
    
    if not mobile or len(mobile) != 10:
        return jsonify({'error': 'Invalid mobile number'}), 400
    
    existing_user = User.query.filter_by(mobile=mobile).first()
    if existing_user:
        return jsonify({'error': 'User with this mobile already exists'}), 409
    
    new_admin = User(
        username=username.strip().lower(),
        mobile=mobile,
        is_admin=True
    )
    
    db.session.add(new_admin)
    db.session.commit()
    
    return jsonify({
        'message': 'Admin user created successfully',
        'user_id': new_admin.id,
        'username': new_admin.username
    }), 201

@app.route('/api/promote-to-admin', methods=['POST'])
def promote_to_admin():
    """Promote an existing user to admin via API"""
    data = request.get_json()
    
    mobile = data.get('mobile')
    username = data.get('username')
    master_key = data.get('master_key')
    
    if master_key != MASTER_ADMIN_KEY:
        return jsonify({'error': 'Invalid master authorization key'}), 403
    
    user = User.query.filter_by(mobile=mobile).first()
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    if user.username.lower() != username.strip().lower():
        return jsonify({'error': 'Username does not match existing account'}), 400
    
    user.is_admin = True
    db.session.commit()
    
    return jsonify({
        'message': 'User promoted to admin successfully',
        'user_id': user.id,
        'username': user.username
    })

@app.route('/api/check-admin', methods=['POST'])
def check_admin():
    """Check if a user is admin via API"""
    data = request.get_json()
    mobile = data.get('mobile')
    
    user = User.query.filter_by(mobile=mobile).first()
    if not user:
        return jsonify({'is_admin': False}), 404
    
    return jsonify({
        'is_admin': user.is_admin,
        'username': user.username
    })

# =========================================
# USER API ROUTES FOR PROFILE & ADMIN MNGMT
# =========================================


@app.route("/api/users-sms/", methods=["GET"])
def get_users_sms():
    users = User.query.all()
    return jsonify([{"id": u.id, "username": u.username, "phone": u.mobile} for u in users])

@app.route("/api/send_sms", methods=["POST"])
def send_sms():
    data = request.json
    phone = data.get("phone")
    message = data.get("message")
    if not phone or not message:
        return jsonify({"success": False, "error": "phone and message required"}), 400
    try:
        res = requests.post("https://textbelt.com/text", json={
            "phone": phone,
            "message": message,
            "key": "textbelt"  # free demo key
        })
        return jsonify(res.json())
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/users/me')
@login_required
def get_current_user():
    """Get current user info"""
    if not current_user.is_authenticated:
        return jsonify({'error': 'Not authenticated'}), 401
    
    return jsonify({
        'id': current_user.id,
        'username': current_user.username,
        'mobile': current_user.mobile,
        'is_admin': current_user.is_admin,
        'created_at': current_user.created_at.isoformat()
    })

@app.route('/api/users/<int:id>')
@login_required
def get_user(id):
    """Get user by ID (Admin only)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403
    
    user = User.query.get_or_404(id)
    return jsonify({
        'id': user.id,
        'username': user.username,
        'mobile': user.mobile,
        'is_admin': user.is_admin,
        'created_at': user.created_at.isoformat()
    })

@app.route('/api/user')
@login_required
def current_user_info():
    """Get current user information"""
    if not current_user.is_authenticated:
        return jsonify({'error': 'Not authenticated'}), 401
    
    return jsonify({
        'id': current_user.id,
        'username': current_user.username,
        'mobile': current_user.mobile,
        'is_admin': current_user.is_admin,
        'created_at': current_user.created_at.isoformat()
    })

#==========================================
#  TOPIC API ROUTES
# =========================================

@app.route('/api/topics/<int:topic_id>/materials')
def get_topic_materials(topic_id):
    """Get all materials for a specific topic"""
    try:
        topic = Topic.query.get_or_404(topic_id)
        materials = TopicMaterial.query.filter_by(topic_id=topic_id)\
            .order_by(TopicMaterial.order_index).all()
        
        materials_data = []
        for material in materials:
            materials_data.append({
                'id': material.id,
                'display_name': material.display_name or material.file.name,
                'description': material.description or material.file.description,
                'file_id': material.file_id,
                'filename': material.file.filename,
                'file_type': material.file.file_type,
                'file_size': material.file.file_size,
                'uploaded_at': material.file.uploaded_at.isoformat(),
                'uploaded_by': material.file.uploader.username,
                'order_index': material.order_index
            })
        
        return jsonify({
            'topic': {
                'id': topic.id,
                'name': topic.name,
                'description': topic.description
            },
            'materials': materials_data
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/topics/<int:topic_id>/materials', methods=['POST'])
@login_required
def add_topic_material(topic_id):
    """Add a material to a topic"""
    try:
        if not current_user.is_admin:
            return jsonify({'error': 'Unauthorized'}), 403
            
        topic = Topic.query.get_or_404(topic_id)
        data = request.get_json()
        
        file_id = data.get('file_id')
        display_name = data.get('display_name')
        description = data.get('description')
        
        if not file_id:
            return jsonify({'error': 'File ID is required'}), 400
            
        file = File.query.get(file_id)
        if not file:
            return jsonify({'error': 'File not found'}), 404
            
        existing_material = TopicMaterial.query.filter_by(
            topic_id=topic_id, file_id=file_id
        ).first()
        
        if existing_material:
            return jsonify({'error': 'Material already exists for this topic'}), 400
        
        max_order = db.session.query(db.func.max(TopicMaterial.order_index))\
            .filter_by(topic_id=topic_id).scalar() or 0
        
        material = TopicMaterial(
            topic_id=topic_id,
            file_id=file_id,
            display_name=display_name,
            description=description,
            order_index=max_order + 1
        )
        
        db.session.add(material)
        db.session.commit()
        
        return jsonify({
            'message': 'Material added successfully',
            'material': {
                'id': material.id,
                'display_name': material.display_name or file.name,
                'file_id': file.id
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/api/topics/<int:topic_id>/materials/<int:material_id>', methods=['DELETE'])
@login_required
def remove_topic_material(topic_id, material_id):
    """Remove a material from a topic"""
    try:
        if not current_user.is_admin:
            return jsonify({'error': 'Unauthorized'}), 403
            
        material = TopicMaterial.query.filter_by(
            id=material_id, topic_id=topic_id
        ).first_or_404()
        
        db.session.delete(material)
        db.session.commit()
        
        return jsonify({'message': 'Material removed successfully'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/api/topics/<int:topic_id>/materials/reorder', methods=['POST'])
@login_required
def reorder_topic_materials(topic_id):
    """Reorder materials in a topic"""
    try:
        if not current_user.is_admin:
            return jsonify({'error': 'Unauthorized'}), 403
            
        data = request.get_json()
        material_order = data.get('order', [])
        
        for index, material_id in enumerate(material_order):
            material = TopicMaterial.query.filter_by(
                id=material_id, topic_id=topic_id
            ).first()
            if material:
                material.order_index = index
        
        db.session.commit()
        return jsonify({'message': 'Materials reordered successfully'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/api/files/available')
@login_required
def get_available_files():
    """Get files that can be added to topics"""
    try:
        search = request.args.get('search', '')
        page = request.args.get('page', 1, type=int)
        per_page = 20
        
        query = File.query
        
        if search:
            query = query.filter(
                db.or_(
                    File.name.ilike(f'%{search}%'),
                    File.description.ilike(f'%{search}%'),
                    File.filename.ilike(f'%{search}%')
                )
            )
        
        files = query.order_by(File.uploaded_at.desc())\
            .paginate(page=page, per_page=per_page, error_out=False)
        
        files_data = []
        for file in files.items:
            files_data.append({
                'id': file.id,
                'name': file.name,
                'filename': file.filename,
                'file_type': file.file_type,
                'file_size': file.file_size,
                'description': file.description,
                'category': file.category,
                'uploaded_at': file.uploaded_at.isoformat(),
                'uploaded_by': file.uploader.username
            })
        
        return jsonify({
            'files': files_data,
            'has_next': files.has_next,
            'has_prev': files.has_prev,
            'current_page': files.page,
            'pages': files.pages,
            'total': files.total
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
#==========================================
from sqlalchemy import func, extract

@app.route('/admin/analytics')
def analytics_dashboard():
    return render_template('analytics.html')

@app.route('/api/track-visit', methods=['POST'])
def track_visit():
    try:
        data = request.get_json()
        
        visit = Visit(
            user_id=data.get('user_id'),
            page=data.get('page', 'main_page'),
            section=data.get('section'),
            session_id=data.get('session_id'),
            user_agent=request.headers.get('User-Agent'),
            timestamp=nairobi_time()
        )
        db.session.add(visit)
        db.session.commit()
        
        # Cleanup old data periodically (every 10th visit)
        if visit.id % 10 == 0:
            cleanup_old_visits()
        
        return jsonify({'status': 'success', 'visit_id': visit.id})
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/api/track-activity', methods=['POST'])
def track_activity():
    try:
        data = request.get_json()
        
        activity = UserActivity(
            user_id=data.get('user_id'),
            action=data.get('action'),
            target=data.get('target'),
            duration=data.get('duration'),
            timestamp=nairobi_time()
        )
        db.session.add(activity)
        db.session.commit()
        
        return jsonify({'status': 'success'})
    except Exception as e:
        return jsonify({'status': 'error'}), 500

@app.route('/api/analytics/visits')
@admin_required
def get_visit_analytics():
    # Last 24 hours data
    cutoff_time = (datetime.utcnow() + timedelta(hours=3)) - timedelta(hours=24)
    
    # Total visits
    total_visits = Visit.query.filter(Visit.timestamp >= cutoff_time).count()
    
    # Unique visitors
    unique_visitors = db.session.query(Visit.user_id).filter(
        Visit.timestamp >= cutoff_time
    ).distinct().count()
    
    # Visits per hour
    visits_per_hour = db.session.query(
        func.extract('hour', Visit.timestamp).label('hour'),
        func.count(Visit.id).label('count')
    ).filter(
        Visit.timestamp >= cutoff_time
    ).group_by(func.extract('hour', Visit.timestamp)).order_by(func.extract('hour', Visit.timestamp)).all()    
    
    # Section popularity
    section_stats = db.session.query(
        Visit.section,
        func.count(Visit.id).label('count')
    ).filter(Visit.timestamp >= cutoff_time).group_by(Visit.section).all()
    
    # User activity timeline
    user_activity = db.session.query(
        UserActivity.action,
        UserActivity.target,
        UserActivity.timestamp,
        User.username
    ).join(User).filter(
        UserActivity.timestamp >= cutoff_time
    ).order_by(UserActivity.timestamp.desc()).limit(50).all()
    
    return jsonify({
        'total_visits': total_visits,
        'unique_visitors': unique_visitors,
        'visits_per_hour': [{'hour': v.hour, 'count': v.count} for v in visits_per_hour],
        'section_stats': [{'section': s.section, 'count': s.count} for s in section_stats],
        'recent_activity': [{
            'action': ua.action,
            'target': ua.target,
            'timestamp': ua.timestamp.isoformat(),
            'username': ua.username
        } for ua in user_activity]
    })

@app.route('/api/analytics/user/<int:user_id>')
@admin_required
def get_user_analytics(user_id):
    cutoff_time = nairobi_time() - timedelta(hours=24)
    
    user_visits = Visit.query.filter(
        Visit.user_id == user_id,
        Visit.timestamp >= cutoff_time
    ).count()
    
    user_activities = UserActivity.query.filter(
        UserActivity.user_id == user_id,
        UserActivity.timestamp >= cutoff_time
    ).order_by(UserActivity.timestamp.desc()).all()
    
    favorite_section = db.session.query(
        Visit.section,
        func.count(Visit.id).label('count')
    ).filter(
        Visit.user_id == user_id,
        Visit.timestamp >= cutoff_time
    ).group_by(Visit.section).order_by(func.count(Visit.id).desc()).first()
    
    return jsonify({
        'visit_count': user_visits,
        'activities': [{
            'action': ua.action,
            'target': ua.target,
            'timestamp': ua.timestamp.isoformat(),
            'duration': ua.duration
        } for ua in user_activities],
        'favorite_section': favorite_section[0] if favorite_section else None
    })
#==========================================
# Error Handlers
#==========================================

@app.errorhandler(404)

def not_found_error(error):
    return render_template('404.html'), 404

@app.errorhandler(403)

def forbidden_error(error):
    return render_template('403.html'), 403

import logging
# Configure logging (only once, ideally in app setup)
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)s in %(module)s: %(message)s'
)

@app.errorhandler(429)

def ratelimit_handler(e):
    client_ip = request.remote_addr or 'unknown'
    route = request.path

    # Log the rate limit event
    logging.warning(f"Rate limit exceeded: IP={client_ip}, Route={route}")

    if route.startswith('/api/'):
        return jsonify({
            "error": "Too many requests",
            "message": "You have exceeded the allowed request limit. Please try again later.",
            "ip": client_ip
        }), 429

    flash("Too many requests. Please wait a moment before trying again.", "error")

    try:
        return render_template(
            'error429.html',
            message="You’ve made too many requests. Please wait a moment and try again."
        ), 429
    except Exception:
        return redirect(url_for('login'))

@app.errorhandler(500)

def internal_error(error):
    app.logger.error(f'Internal Server Error: {error}', exc_info=True)
    flash('Oops! Something went wrong. Try again.', 'error')

    referrer = request.referrer
    flash('An unexpected error occurred. Please try again later.', 'error')
    if referrer:
        return redirect(referrer), 302
    else:
        return redirect(url_for('home')), 302

# ==========================================
if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=47947, debug=False)